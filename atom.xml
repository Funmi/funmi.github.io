<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>方米团队博客</title>
  
  <subtitle>记录成长的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-17T09:24:53.796Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>方米团队</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue+MUI+HBuilder开发H5+应用</title>
    <link href="http://yoursite.com/2018/05/17/Vue-MUI-HBuilder%E5%BC%80%E5%8F%91H5-%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/17/Vue-MUI-HBuilder开发H5-应用/</id>
    <published>2018-05-17T08:53:26.000Z</published>
    <updated>2018-05-17T09:24:53.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5117775-dacb73f9b53d7793.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="&quot;&quot;"></p><p>自从移动端跨平台开发概念开始兴起后，出来很多解决方案，不管是框架生成原生控件，还是直接外面套个webview做个H5应用，这些方案都给移动开发带来了便利。</p><a id="more"></a><h2 id="什么是MUI"><a href="#什么是MUI" class="headerlink" title="什么是MUI"></a>什么是MUI</h2><blockquote><p><a href="https://dev.dcloud.net.cn/mui/ui/" target="_blank" rel="noopener">MUI是最近接原生App体验的高性能前端框架</a></p></blockquote><h2 id="MUI有什么特点，为什么要使用MUI？"><a href="#MUI有什么特点，为什么要使用MUI？" class="headerlink" title="MUI有什么特点，为什么要使用MUI？"></a>MUI有什么特点，为什么要使用MUI？</h2><p>首先再次我需要先声明一下我的个人观点：我们在使用一个框架或者库的时候，应该尽量去迁就这个框架自身的特点，并且充分利用好这些特点，这样才有意义，不然你为什么不自己去写个框架呢？</p><h3 id="专门为移动开发设计的"><a href="#专门为移动开发设计的" class="headerlink" title="专门为移动开发设计的"></a>专门为移动开发设计的</h3><p>MUI是专门为移动开发而设计的框架，来自<a href="https://www.dcloud.io/" target="_blank" rel="noopener">DCloud</a>的团队，不是从PC搬过来的，也没有过于冗余的设计，专注则必然专业。</p><h3 id="轻巧"><a href="#轻巧" class="headerlink" title="轻巧"></a>轻巧</h3><p>体积相比其他类似框架要小很多，H5在先天上确实比不上原生的体验和性能，所以我们更加要考虑它的精确而不冗余，不希望我们的页面加载过程中需要去初始化一些用不到的内容。</p><h3 id="简单易懂"><a href="#简单易懂" class="headerlink" title="简单易懂"></a>简单易懂</h3><p>MUI配合Vue一起使用简单易懂，上手较快。</p><h3 id="HBuilder开发工具的强力支持"><a href="#HBuilder开发工具的强力支持" class="headerlink" title="HBuilder开发工具的强力支持"></a>HBuilder开发工具的强力支持</h3><p>毕竟是一家的产品，可以说HBuilder为MUI的发展插上了翅膀，强大的提示功能以及代码块的实现真的非常方便，很多常用的功能都提供了快捷生成的功能，比如导航栏、Tab、图片轮播等等。另外打包过程也变得非常easy，云端打包，或者本地打包都可以。</p><h3 id="HTML5-的支持"><a href="#HTML5-的支持" class="headerlink" title="HTML5+的支持"></a>HTML5+的支持</h3><p>H5+的提供了众多原生API可以调用，使得H5开发过程中能够更加逼近原生体验，包括UI、硬件调用、分享、三方登录、文件操作等等。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>首先使用Vue cli先快速创建一个模板项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br><span class="line">$ vue init Funmi/vue-template-for-hbuilder my-project</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br><span class="line">$ yarn (推荐使用yarn，应为yarn确实比npm好用很多)</span><br><span class="line">$ yarn dev</span><br></pre></td></tr></table></figure><p>使用Hbuilder打开<code>my-project/dist</code>中的目录，打开 <code>manifest.json</code> 点击云端获取，获取appid，并同步到 <code>src/manifest.json</code> 中，然后真机运行。<br>npm run dev 后代码会自动更新到 <code>dist</code> 目录，请不要用 <code>Hbuilder</code> 打开编译后的文件，以免影响真机测试。</p><h3 id="Build-Setup"><a href="#Build-Setup" class="headerlink" title="Build Setup"></a>Build Setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动编译结果到指定文件夹</span></span><br><span class="line">yarn dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:8080</span></span><br><span class="line">yarn webdev</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production with minification</span></span><br><span class="line">yarn build</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production and view the bundle analyzer report</span></span><br><span class="line">yarn build --report</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="yarn-webdev看不到界面"><a href="#yarn-webdev看不到界面" class="headerlink" title="yarn webdev看不到界面"></a>yarn webdev看不到界面</h3><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://github.com/Funmi/HBuildTest/tree/master/template" target="_blank" rel="noopener">HBuildTest</a>, 一个H5的Hbuilder示例，里面有调用原生相关Demo。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5117775-dacb73f9b53d7793.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;自从移动端跨平台开发概念开始兴起后，出来很多解决方案，不管是框架生成原生控件，还是直接外面套个webview做个H5应用，这些方案都给移动开发带来了便利。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="MUI" scheme="http://yoursite.com/tags/MUI/"/>
    
      <category term="HBuilder" scheme="http://yoursite.com/tags/HBuilder/"/>
    
  </entry>
  
  <entry>
    <title>安装Drupal8需要环境</title>
    <link href="http://yoursite.com/2018/03/01/%E5%AE%89%E8%A3%85Drupal8%E9%9C%80%E8%A6%81%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/03/01/安装Drupal8需要环境/</id>
    <published>2018-03-01T06:05:01.000Z</published>
    <updated>2018-03-01T06:06:59.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Drupal8需要环境"><a href="#安装Drupal8需要环境" class="headerlink" title="安装Drupal8需要环境"></a>安装Drupal8需要环境</h2><p>环境：UNIX/Linux,OS X,或者windows<br>web服务器： Apache2，nginx,Microsoft IIS等<br>数据库：推荐数据库 Mysql(5.5.3)，MariaDB(5.5.20),Percona Server(5.5.8)，支持：PostgreSql(9.1.2),SQLite(3.6.8)<br><a id="more"></a></p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>我的环境，OS X，Apache2,Mysql(7.02)<br>1.连接Drupal<a href="https://www.drupal.org/download" target="_blank" rel="noopener">官网</a><br><img src="http://upload-images.jianshu.io/upload_images/1901812-9b80a813d9096db9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>2.选择适合您操作系统的压缩文件，Windows选择.zip格式下载，Linux系统两种格式都可以选择，当前最新稳定版本为8.4.5，推荐使用Drupal8 以上的版本，Drupal7是目前模块最多的版本。</p><p>3.<a href="https://www.drupal.org/project/usage/drupal" target="_blank" rel="noopener">点击</a>了解Drupal各个版本的历史安装情况。从下图中可以发现Drupal7 仍然是目前使用最多的版本。<br><img src="http://upload-images.jianshu.io/upload_images/1901812-72c3a6fc6a4e573e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>4.将刚刚下载好的Drupal8 安装包解压到你本地服务器根目录。从浏览器中访问刚才解压的Drupal项目进入以下安装界面：</p><p><img src="http://upload-images.jianshu.io/upload_images/1901812-b68c960a2e8260b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>5.选择简体中文保存并继续安装<br><img src="http://upload-images.jianshu.io/upload_images/1901812-b8683a6d8215a99b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>6.选择’标准’保存并继续会出现以下配置数据库界面，填写你的数据库相关信息。</p><p><img src="http://upload-images.jianshu.io/upload_images/1901812-e3ca7bc539489ed0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>7.安装完成后会出现以下设置网站信息界面，设置网站的基本信息</p><p><img src="http://upload-images.jianshu.io/upload_images/1901812-10103a82e6edf291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>8.设置成功后，网站则安装成功可以进入你的项目</p><p><img src="http://upload-images.jianshu.io/upload_images/1901812-a5a863721beb8b57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>9.安装成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Drupal8需要环境&quot;&gt;&lt;a href=&quot;#安装Drupal8需要环境&quot; class=&quot;headerlink&quot; title=&quot;安装Drupal8需要环境&quot;&gt;&lt;/a&gt;安装Drupal8需要环境&lt;/h2&gt;&lt;p&gt;环境：UNIX/Linux,OS X,或者windows&lt;br&gt;web服务器： Apache2，nginx,Microsoft IIS等&lt;br&gt;数据库：推荐数据库 Mysql(5.5.3)，MariaDB(5.5.20),Percona Server(5.5.8)，支持：PostgreSql(9.1.2),SQLite(3.6.8)&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift编码规范</title>
    <link href="http://yoursite.com/2017/03/20/Swift%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2017/03/20/Swift编程规范/</id>
    <published>2017-03-20T02:08:12.000Z</published>
    <updated>2018-03-01T05:49:39.754Z</updated>
    
    <content type="html"><![CDATA[<p>关于Swift的代码的相关规范，不同的开发者都有自己相应的规范，可能还是很多人根本就没有规范。为了保证同一个公司同一个项目组中代码美观并且一致，这里写下这份Swift编程规范指南。该指南首要目标是让代码紧凑，可读性更高且简洁。</p><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><ul><li>使用四个空格进行缩进</li><li>每行最多160个字符，这样可以避免一行过长（Xcode-&gt;Preferences-&gt;Text Editing-&gt;Page guide at column: 设置成160即可）</li><li>确保每个文件结尾都有空白行</li><li>确保每行都不以空白符作为结尾（Xcode-&gt;Preferences-&gt;Text Editing-&gt;Automatically trim trailing whitespace + Including whitespace-only lines）</li><li><p>左大括号不用另起一行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> x == z &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要在逗号后面加空格</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>二元运算符（+，==，或&gt;）的前后都需要添加空格，左小括号和右小括号前面不需要空格。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">20</span> + (<span class="number">34</span> / <span class="number">2</span>) * <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pancake</span> -&gt; <span class="title">Pancake</span> </span>&#123;</span><br><span class="line"><span class="comment">/** do something **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遵守Xcode内置的缩进格式，当声明的一个函数需要跨多行时，推荐使用Xcode默认格式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xcode针对跨多行函数声明缩进</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunctionWithManyParameters</span><span class="params">(parameterOne: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  parameterTwo: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  parameterThree: String)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Xcode会自动缩进</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(parameterOne) \(parameterTwo) \(parameterThree)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Xcode针对多行 if 语句的缩进</span></span><br><span class="line"><span class="keyword">if</span> myFirstVariable &gt; (mySecondVariable + myThirdVariable)</span><br><span class="line">    &amp;&amp; myFourthVariable == .<span class="type">SomeEnumValue</span> &#123;</span><br><span class="line">    <span class="comment">// Xcode会自动缩进</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当调用一个函数有多个参数时，每个参数另起一行，比函数名多一个缩进。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">functionWithArguments(</span><br><span class="line">    firstArgument: <span class="string">"Hello, I am a string"</span>,</span><br><span class="line">    secondArgument: resultFromSomeFunction()</span><br><span class="line">    thirdArgument: someOtherLocalVariable)</span><br></pre></td></tr></table></figure></li><li><p>当遇到需要处理的数组或字典内容较多需要多行显示时，需要把[和]类似方法体里面的括号，方法体里的闭合也要做类似的处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">functionWithBunchOfArguments(</span><br><span class="line">    someStringArgument: <span class="string">"hello I am a string"</span>,</span><br><span class="line">    someArrayArgument: [</span><br><span class="line">        <span class="string">"dadada daaaa daaaa dadada daaaa daaaa dadada daaaa daaaa"</span>,</span><br><span class="line">        <span class="string">"string one is crazy - what is it thinking?"</span></span><br><span class="line">    ],</span><br><span class="line">    someDictionaryArgument: [</span><br><span class="line">        <span class="string">"dictionary key 1"</span>: <span class="string">"some value 1, but also some more text here"</span>,</span><br><span class="line">        <span class="string">"dictionary key 2"</span>: <span class="string">"some value 2"</span></span><br><span class="line">    ],</span><br><span class="line">    someClosure: &#123; parameter1 <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(parameter1)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>尽量避免出现多行断言，可使用本地变量或其他策略</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">let</span> firstCondition = x == firstReallyReallyLongPredicateFunction()</span><br><span class="line"><span class="keyword">let</span> secondCondition = y == secondReallyReallyLongPredicateFunction()</span><br><span class="line"><span class="keyword">let</span> thirdCondition = z == thirdReallyReallyLongPredicateFunction()</span><br><span class="line"><span class="keyword">if</span> firstCondition &amp;&amp; secondCondition &amp;&amp; thirdCondition &#123;</span><br><span class="line">    <span class="comment">// 你要干什么</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> x == firstReallyReallyLongPredicateFunction()</span><br><span class="line">    &amp;&amp; y == secondReallyReallyLongPredicateFunction()</span><br><span class="line">    &amp;&amp; z == thirdReallyReallyLongPredicateFunction() &#123;</span><br><span class="line">    <span class="comment">// 你要干什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>使用帕斯卡拼写法（又名大骆驼拼写法，首字母大写）为类型命名（如struct，enum，class，typedef，associatedtype等）。</li><li>使用小骆驼拼写法（首字母小写）为函数，方法，常亮，参数等命名。</li><li><p>首字母缩略词在命名中一般来说都是全部大写，例外的情形是如果首字母缩略词是一个命名的开始部分，而这个命名需要小写字母作为开头，这种情形下首字母缩略词全部小写。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "HTML" 是变量名的开头, 需要全部小写 "html"</span></span><br><span class="line"><span class="keyword">let</span> htmlBodyContent: <span class="type">String</span> = <span class="string">"&lt;p&gt;Hello, World!&lt;/p&gt;"</span></span><br><span class="line"><span class="comment">// 推荐使用 ID 而不是 Id</span></span><br><span class="line"><span class="keyword">let</span> profileID: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 推荐使用 URLFinder 而不是 UrlFinder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用前缀 k + 大骆驼命名法 为所有非单例的静态常量命名。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基元常量使用 k 作为前缀</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> kSomeConstantHeight: <span class="type">CGFloat</span> = <span class="number">80.0</span></span><br><span class="line">    <span class="comment">// 非基元常量也是用 k 作为前缀</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> kDeleteButtonColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">    <span class="comment">// 对于单例不要使用k作为前缀</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">MyClassName</span>()</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名应该具有描述性个清晰性的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundAnimatingButton</span>: <span class="title">UIButton</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span>: <span class="title">UIButton</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>不要缩写、简写或单个字母命名。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundAnimatingButton</span>: <span class="title">UIButton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> animationDuration: <span class="type">NSTimeInterval</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startAnimating</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> firstSubview = subviews.first</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundAnimating</span>: <span class="title">UIButton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> aniDur: <span class="type">NSTimeInterval</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">srtAnmating</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> v = subviews.first</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果原有命名不能明显表明类型，则属性命名内要包括类型信息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionTableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> personImageView: <span class="type">UIImageView</span></span><br><span class="line">    <span class="keyword">let</span> animationDuration: <span class="type">NSTimeInterval</span></span><br><span class="line">    <span class="comment">// 作为属性名的firstName，很明显是字符串类型，所以不用在命名里不用包含String</span></span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 虽然不推荐, 这里用 Controller 代替 ViewController 也可以。</span></span><br><span class="line">    <span class="keyword">let</span> popupController: <span class="type">UIViewController</span></span><br><span class="line">    <span class="keyword">let</span> popupViewController: <span class="type">UIViewController</span></span><br><span class="line">    <span class="comment">// 如果需要使用UIViewController的子类，如TableViewController, CollectionViewController, SplitViewController, 等，需要在命名里标名类型。</span></span><br><span class="line">    <span class="keyword">let</span> popupTableViewController: <span class="type">UITableViewController</span></span><br><span class="line">    <span class="comment">// 当使用outlets时, 确保命名中标注类型。</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> submitButton: <span class="type">UIButton</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> emailTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> nameLabel: <span class="type">UILabel</span>!</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionTableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个不是 UIImage, 不应该以Image 为结尾命名。</span></span><br><span class="line">    <span class="comment">// 建议使用 personImageView</span></span><br><span class="line">    <span class="keyword">let</span> personImage: <span class="type">UIImageView</span></span><br><span class="line">    <span class="comment">// 这个不是String，应该命名为 textLabel</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">UILabel</span></span><br><span class="line">    <span class="comment">// animation 不能清晰表达出时间间隔</span></span><br><span class="line">    <span class="comment">// 建议使用 animationDuration 或 animationTimeInterval</span></span><br><span class="line">    <span class="keyword">let</span> animation: <span class="type">NSTimeInterval</span></span><br><span class="line">    <span class="comment">// transition 不能清晰表达出是String</span></span><br><span class="line">    <span class="comment">// 建议使用 transitionText 或 transitionString</span></span><br><span class="line">    <span class="keyword">let</span> transition: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 这个是ViewController，不是View</span></span><br><span class="line">    <span class="keyword">let</span> popupView: <span class="type">UIViewController</span></span><br><span class="line">    <span class="comment">// 由于不建议使用缩写，这里建议使用 ViewController替换 VC</span></span><br><span class="line">    <span class="keyword">let</span> popupVC: <span class="type">UIViewController</span></span><br><span class="line">    <span class="comment">// 技术上讲这个变量是 UIViewController, 但应该表达出这个变量是TableViewController</span></span><br><span class="line">    <span class="keyword">let</span> popupViewController: <span class="type">UITableViewController</span></span><br><span class="line">    <span class="comment">// 为了保持一致性，建议把类型放到变量的结尾，而不是开始，如submitButton</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> btnSubmit: <span class="type">UIButton</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> buttonSubmit: <span class="type">UIButton</span>!</span><br><span class="line">    <span class="comment">// 在使用outlets 时，变量名内应包含类型名。</span></span><br><span class="line">    <span class="comment">// 这里建议使用 firstNameLabel</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> firstName: <span class="type">UILabel</span>!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当给函数参数命名时，要确保函数能够理解每个参数的目的。</p></li></ul><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><ul><li>尽可能多使用let，少使用var。</li><li><p>当需要遍历一个集合变形成另一个集合时，推荐使用函数flatMap，filter，和reduce。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">let</span> stringOfInts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].flatMap &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="comment">// ["1", "2", "3"]</span></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> stringOfInts: [<span class="type">String</span>] = []</span><br><span class="line"><span class="keyword">for</span> integer <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123;</span><br><span class="line">    stringOfInts.append(<span class="type">String</span>(integer))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">let</span> evenNumbers = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>].<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// [4, 8, 16, 42]</span></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> evenNumbers: [<span class="type">Int</span>] = []</span><br><span class="line"><span class="keyword">for</span> integer <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>] &#123;</span><br><span class="line">    <span class="keyword">if</span> integer % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        evenNumbers(integer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果变量类型可以依靠判断得出，不建议声明变量时指明类型。</p></li><li><p>如果一个函数有多个返回值，推荐使用 元组 而不是<code>inout</code>参数，如果这个元组在多个地方都会使用，建议使用typealias来定义这个元组，而如果返回的元组有三个或者三个以上的元素，建议使用结构体或类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pirateName</span><span class="params">()</span></span> -&gt; (firstName: <span class="type">String</span>, lastName: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"Guybrush"</span>, <span class="string">"Threepwood"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = pirateName()</span><br><span class="line"><span class="keyword">let</span> firstName = name.firstName</span><br><span class="line"><span class="keyword">let</span> lastName = name.lastName</span><br></pre></td></tr></table></figure></li><li><p>当使用委托和协议时，请注意避免出现循环引用，基本上是在定义属性的时候使用weak修饰。</p></li><li><p>在闭包里使用self的时候需要注意避免出现循环引用，使用捕获列表可以避免这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functionWithClosure() &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 方案 1</span></span><br><span class="line">    <span class="keyword">self</span>?.doSomething()</span><br><span class="line">    <span class="comment">// 或方案 2</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    strongSelf.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch 模块中不用显式使用break。</p></li><li><p>断言流程控制的时候不要使用小括号。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> x == y &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在写枚举类型的时候，尽量简写。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">imageView.setImageWithURL(url, type: .person)</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">imageView.setImageWithURL(url, type: <span class="type">AsyncImageView</span>.<span class="type">Type</span>.person)</span><br></pre></td></tr></table></figure></li><li><p>在使用类方法的时候不用简写，因为类方法和枚举类型不一样，不能轻易地推导出上下文。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">imageView.backgroundColor = <span class="type">UIColor</span>.whiteColor()</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">imageView.backgroundColor = .whiteColor()</span><br></pre></td></tr></table></figure></li><li><p>不建议使用self，除非必须得要。</p></li><li>在写一个方法的时候，需要衡量这个方法将来是否会被重写，如果不是请用final关键字修饰，这样组织方法被重写。一般来说final修饰符可以优化编译速度，在合适的时候大胆的使用它吧。需要注意的是，在一个公开发布的代码库中使用final和在本地项目中使用final的影响差别很大。</li><li>在使用一些语句如else，catch等紧随代码块关键字的时候，确保代码块和关键字在同一行。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> someBoolean &#123;</span><br><span class="line">    <span class="comment">// 你想要什么</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 你不想做什么</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fileContents = <span class="keyword">try</span> readFile(<span class="string">"filename.txt"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><ul><li><p>如果需要把访问修饰符放到第一个位置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> kMyPrivateNumber: <span class="type">Int</span></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">let</span> kMyPrivateNumber: <span class="type">Int</span></span><br></pre></td></tr></table></figure></li><li><p>访问修饰符不应该单独另起一行，应和访问修饰符描述的对象保持在同一行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pirate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pirate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认的访问修饰符是internal，可省略不写。</p></li><li>当一个变量需要被单元测试 访问时，需要声明为 internal 类型来使用@testable import {ModuleName}。 如果一个变量实际上是private 类型，而因为单元测试需要被声明为 internal 类型，确定添加合适的注释文档来解释为什么这么做。这里添加注释推荐使用 - warning: 标记语法。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 这个变量是private 名字</span></span><br><span class="line"><span class="comment"> - warning: 定义为 internal 而不是 private 为了 `@testable`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> pirateName = <span class="string">"LeChuck"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h3><ul><li>不推荐使用自定义操作符，如果需要创建函数代替。</li><li>在重写操作符之前，请慎重考虑是否有充分的理由一定要在全局范围内创建新的操作符，而不是使用其他策略。</li><li>你可以重载现有的操作符来支持新的类型（特别是==），但是新定义的必须保留操作符原来的含义，比如==必须用来测试是否相等并返回布尔值。</li></ul><h3 id="switch语句和枚举"><a href="#switch语句和枚举" class="headerlink" title="switch语句和枚举"></a>switch语句和枚举</h3><ul><li>使用swift语句时，如果选项是有限集合时，不要使用default，相反的，把一些不用的选项放到底部，并用break关键词阻止其执行。</li><li>应为swift中的switch选项默认是包含break的，所以不需要使用break关键字。</li><li>case 语句 应和 switch 语句左对齐，并在 标准的 default 上面。</li><li><p>当定义的选项有关联值时，确保关联值有恰当的名称，而不只是类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Problem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> attitude</span><br><span class="line">    <span class="keyword">case</span> hair</span><br><span class="line">    <span class="keyword">case</span> hunger(hungerLevel: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleProblem</span><span class="params">(problem: Problem)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> problem &#123;</span><br><span class="line">    <span class="keyword">case</span> .attitude:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"At least I don't have a hair problem."</span>)</span><br><span class="line">    <span class="keyword">case</span> .hair:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Your barber didn't know when to stop."</span>)</span><br><span class="line">    <span class="keyword">case</span> .hunger(<span class="keyword">let</span> hungerLevel):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The hunger level is \(hungerLevel)."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>推荐尽可能使用fall through。</p></li><li>如果default 的选项不应该触发，可以抛出错误 或 断言类似的做法。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleDigit</span><span class="params">(digit: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Yes, \(digit) is a digit!"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">Error</span>(message: <span class="string">"The given number was not a digit."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h3><ul><li>唯一使用隐式拆包可选型的场景是结合@IBOutlets，在其他场景使用非可选类型和常规可选类型，即使有的场景你确定有的变量使用的时候永远不会为nil，但这样做可以保持一致性和程序更加健壮。</li><li>不要使用as!和try!，除非万不得已。</li><li><p>如果对于一个变量你不打算声明为可选类型，但当需要检查变量值是否为nil，推荐使用当前值和nil直接比较，而不推荐使用if let的语法。并且nil在前变量在后。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">nil</span> != someOptional &#123;</span><br><span class="line">    <span class="comment">// 你要做什么</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = someOptional &#123;</span><br><span class="line">    <span class="comment">// 你要做什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要使用unowned，unowned和weak修饰变量基本上等价，并且都是隐式拆包（unowned在引用计数上有少许性能优化），由于不推荐使用隐式拆包，也不推荐使用unowned变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> parentViewController: <span class="type">UIViewController</span>?</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> parentViewController: <span class="type">UIViewController</span>!</span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">var</span> parentViewController: <span class="type">UIViewController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> myVariable = myVariable <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>在实现协议的时候，有两种方式来组织你的代码：</p><ul><li>使用//MAKR:注释来实现分割协议和其他代码。</li><li>使用 extension 在 类/结构体已有代码外，但在同一个文件内。<br>请注意 extension 内的代码不能被子类重写，这也意味着测试很难进行。 如果这是经常发生的情况，为了代码一致性最好统一使用第一种办法。否则使用第二种办法，其可以代码分割更清晰。使用而第二种方法的时候，使用  // MARK:  依然可以让代码在 Xcode 可读性更强。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>对于只读属性，提供getter而不是get{}。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computedProperty: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> someBool &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm a mighty pirate!"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I'm selling these fine leather jackets."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于属性相关方法 get {}, set {}, willSet, 和 didSet, 确保缩进相关代码块。</p></li><li><p>对于willSet/didSet 和 set 中的旧值和新值虽然可以自定义名称，但推荐使用默认标准名称 newValue/oldValue。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computedProperty: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> someBool &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I'm a mighty pirate!"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm selling these fine leather jackets."</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        computedProperty = newValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">willSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"will set to \(newValue)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"did set from \(oldValue) to \(newValue)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在创建常量的时候，使用static关键字修饰。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> kReuseIdentifier = <span class="type">String</span>(<span class="type">MyTableViewCell</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> kCellHeight: <span class="type">CGFloat</span> = <span class="number">80.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明单例属性可以通过下面方式进行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PirateManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">PirateManager</span>()</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>如果参数的类型很明显，可以在函数名里可以省略参数类型, 但明确声明类型也是允许的。 代码的可读性有时候是添加详细的信息，而有时候部分重复，根据你的判断力做出选择吧，但前后要保持一致性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略类型</span></span><br><span class="line">doSomethingWithClosure() &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(response)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 明确指出类型</span></span><br><span class="line">doSomethingWithClosure() &#123; response: <span class="type">NSURLResponse</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(response)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map 语句使用简写</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].flatMap &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果使用捕捉列表 或 有具体的非 Void返回类型，参数列表应该在小括号内， 否则小括号可以省略。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为使用捕捉列表，小括号不能省略。</span></span><br><span class="line">doSomethingWithClosure() &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (response: <span class="type">NSURLResponse</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.handleResponse(response)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为返回类型，小括号不能省略。</span></span><br><span class="line">doSomethingWithClosure() &#123; (response: <span class="type">NSURLResponse</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果闭包是变量类型，不需把变量值放在括号中，除非需要，如变量类型是可选类型(Optional?)， 或当前闭包在另一个闭包内。确保闭包里的所以参数放在小括号中，这样()表示没有参数，Void 表示不需要返回值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionBlock: (success: <span class="type">Bool</span>) -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Success? \(success)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> completionBlock: () -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Completed!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> completionBlock: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>基本上不要通过下标直接访问数组内容，如果可能使用.first或.last，因为这些方法是非强制类型并不会奔溃。推荐尽可能使用 for item in items 而不是 for i in 0..n。</li><li>不是使用+=或+操作符给数组添加新元素，使用性能较好的.append()或appendContentsOf()，如果需要声明数组基于其他数组并保持不可变类型，使用let myNewArray = [arr1, arr2].flatten()，而不是let myNewArray = arr1 + arr2 。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>假设一个函数 myFunction 返回类型声明为 String，但是总有可能函数会遇到error，有一种解决方案是返回类型声明为 String?, 当遇到错误的时候返回 nil。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(withFilename filename: String)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> file = openFile(filename) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fileContents = file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    <span class="keyword">return</span> fileContents</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSomeFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> filename = <span class="string">"somefile.txt"</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> fileContents = readFile(filename) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"不能打开 \(filename)."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(fileContents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上如果预知失败的原因，我们应该使用Swift 中的 try/catch 。<br>定义 错误对象 结构体如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> file: <span class="type">StaticString</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> function: <span class="type">StaticString</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> line: <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(message: <span class="type">String</span>, file: <span class="type">StaticString</span> = #file, function: <span class="type">StaticString</span> = #function, line: <span class="type">UInt</span> = #line) &#123;</span><br><span class="line">        <span class="keyword">self</span>.file = file</span><br><span class="line">        <span class="keyword">self</span>.function = function</span><br><span class="line">        <span class="keyword">self</span>.line = line</span><br><span class="line">        <span class="keyword">self</span>.message = message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用案例:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(withFilename filename: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> file = openFile(filename) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">Error</span>(message: “打不开的文件名称 \(filename).<span class="string">")</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    let fileContents = file.read()</span></span><br><span class="line"><span class="string">    file.close()</span></span><br><span class="line"><span class="string">    return fileContents</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">func printSomeFile() &#123;</span></span><br><span class="line"><span class="string">    do &#123;</span></span><br><span class="line"><span class="string">        let fileContents = try readFile(filename)</span></span><br><span class="line"><span class="string">        print(fileContents)</span></span><br><span class="line"><span class="string">    &#125; catch &#123;</span></span><br><span class="line"><span class="string">        print(error)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>其实项目中还是有一些场景更适合声明为可选类型，而不是错误捕捉和处理，比如在获取远端数据过程中遇到错误，nil作为返回结果是合理的，也就是声明返回可选类型比错误处理更合理。</p><p>整体上说，如果一个方法有可能失败，并且使用可选类型作为返回类型会导致错误原因湮没，不妨考虑抛出错误而不是吃掉它。</p><h3 id="使用-guard-语句"><a href="#使用-guard-语句" class="headerlink" title="使用 guard 语句"></a>使用 guard 语句</h3><ul><li><p>总体上，我们推荐使用提前返回的策略，而不是 if 语句的嵌套。使用 guard 语句可以改善代码的可读性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eatDoughnut</span><span class="params">(atIndex index: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; doughnuts <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 index 超出允许范围，提前返回。</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> doughnut = doughnuts[index]</span><br><span class="line">    eat(doughnut)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eatDoughnuts</span><span class="params">(atIndex index: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; donuts.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> doughnut = doughnuts[index]</span><br><span class="line">        eat(doughnut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在解析可选类型时，推荐使用 guard 语句，而不是 if 语句，因为 guard 语句可以减少不必要的嵌套缩进。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> monkeyIsland = monkeyIsland <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">bookVacation(onIsland: monkeyIsland)</span><br><span class="line">bragAboutVacation(onIsland: monkeyIsland)</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> monkeyIsland = monkeyIsland &#123;</span><br><span class="line">    bookVacation(onIsland: monkeyIsland)</span><br><span class="line">    bragAboutVacation(onIsland: monkeyIsland)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止</span></span><br><span class="line"><span class="keyword">if</span> monkeyIsland == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">bookVacation(onIsland: monkeyIsland!)</span><br><span class="line">bragAboutVacation(onIsland: monkeyIsland!)</span><br></pre></td></tr></table></figure></li><li><p>当解析可选类型需要决定在 if 语句 和 guard 语句之间做选择时，最重要的判断标准是是否让代码可读性更强，实际项目中会面临更多的情景，如依赖 2 个不同的布尔值，复杂的逻辑语句会涉及多次比较等，大体上说，根据你的判断力让代码保持一致性和更强可读性， 如果你不确定 if 语句 和 guard 语句哪一个可读性更强，建议使用 guard 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if 语句更有可读性</span></span><br><span class="line"><span class="keyword">if</span> operationFailed &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// guard 语句这里有更好的可读性</span></span><br><span class="line"><span class="keyword">guard</span> isSuccessful <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双重否定不易被理解 - 不要这么做</span></span><br><span class="line"><span class="keyword">guard</span> !operationFailed <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要在2个状态间做出选择，建议使用if 语句，而不是使用 guard 语句。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> isFriendly &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"你好, 远路来的朋友！"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(“穷小子，哪儿来的？<span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 不推荐</span></span><br><span class="line"><span class="string">guard isFriendly else &#123;</span></span><br><span class="line"><span class="string">    print("</span>穷小子，哪儿来的？<span class="string">")</span></span><br><span class="line"><span class="string">    return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print("</span>你好, 远路来的朋友！<span class="string">")</span></span><br></pre></td></tr></table></figure></li><li><p>你只应该在在失败情形下退出当前上下文的场景下使用 guard 语句，下面的例子可以解释 if 语句有时候比 guard 语句更合适 – 我们有两个不相关的条件，不应该相互阻塞。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> monkeyIsland = monkeyIsland &#123;</span><br><span class="line">    bookVacation(onIsland: monkeyIsland)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> woodchuck = woodchuck <span class="keyword">where</span> canChuckWood(woodchuck) &#123;</span><br><span class="line">    woodchuck.chuckWood()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们会经常遇到使用 guard 语句拆包多个可选值，如果所有拆包失败的错误处理都一致可以把拆包组合到一起 (如 return, break, continue,throw 等)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合在一起因为可能立即返回</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> thingOne = thingOne,</span><br><span class="line">    <span class="keyword">let</span> thingTwo = thingTwo,</span><br><span class="line">    <span class="keyword">let</span> thingThree = thingThree <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用独立的语句 因为每个场景返回不同的错误</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> thingOne = thingOne <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">Error</span>(message: <span class="string">"Unwrapping thingOne failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> thingTwo = thingTwo <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">Error</span>(message: <span class="string">"Unwrapping thingTwo failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> thingThree = thingThree <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">Error</span>(message: <span class="string">"Unwrapping thingThree failed."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="文档-注释"><a href="#文档-注释" class="headerlink" title="文档/注释"></a>文档/注释</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>如果一个函数比 O(1) 复杂度高，你需要考虑为函数添加注释，因为函数签名(方法名和参数列表) 并不是那么的一目了然，这里推荐比较流行的插件 VVDocumenter. 不论出于何种原因，如果有任何奇淫巧计不易理解的代码，都需要添加注释，对于复杂的 类/结构体/枚举/协议/属性 都需要添加注释。所有公开的 函数/类/变量/枚举/协议/属性/常数 也都需要添加文档，特别是 函数声明(包括名称和参数列表) 不是那么清晰的时候。<br>在注释文档完成后，你应检查格式是否正确。<br>注释文档规则如下：</p><ul><li>一行不要超过160个字符 (和代码长度限制雷同)。</li><li>即使文档注释只有一行，也要使用模块化格式 (/*<em> </em>/)。</li><li>注释模块中的空行不要使用 * 来占位。</li><li>确定使用新的 – parameter 格式，而不是就得 Use the new -:param: 格式，另外注意 parameter 是小写的。</li><li>如果需要给一个方法的 参数/返回值/抛出异常 添加注释，务必给所有的添加注释，即使会看起来有部分重复，否则注释会看起来不完整，有时候如果只有一个参数值得添加注释，可以在方法注释里重点描述。</li><li><p>对于负责的类，在描述类的使用方法时可以添加一些合适的例子，请注意Swift注释是支持 MarkDown 语法的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ## 功能列表</span></span><br><span class="line"><span class="comment"> 这个类提供下一下很赞的功能，如下:</span></span><br><span class="line"><span class="comment"> - 功能 1</span></span><br><span class="line"><span class="comment"> - 功能 2</span></span><br><span class="line"><span class="comment"> - 功能 3</span></span><br><span class="line"><span class="comment"> ## 例子</span></span><br><span class="line"><span class="comment"> 这是一个代码块使用四个空格作为缩进的例子。</span></span><br><span class="line"><span class="comment">     let myAwesomeThing = MyAwesomeClass()</span></span><br><span class="line"><span class="comment">     myAwesomeThing.makeMoney()</span></span><br><span class="line"><span class="comment"> ## 警告</span></span><br><span class="line"><span class="comment"> 使用的时候总注意以下几点</span></span><br><span class="line"><span class="comment"> 1. 第一点</span></span><br><span class="line"><span class="comment"> 2. 第二点</span></span><br><span class="line"><span class="comment"> 3. 第三点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAwesomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在写文档注释时，尽量保持简洁。</p></li></ul><h3 id="其他注释原则"><a href="#其他注释原则" class="headerlink" title="其他注释原则"></a>其他注释原则</h3><ul><li>// 后面要保留空格。</li><li>注释必须要另起一行。</li><li>使用注释 // MARK: - xoxo 时, 下面一行保留为空行。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pirate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MARK: - 实例属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> pirateName: <span class="type">String</span></span><br><span class="line">    <span class="comment">// MARK: - 初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Swift的代码的相关规范，不同的开发者都有自己相应的规范，可能还是很多人根本就没有规范。为了保证同一个公司同一个项目组中代码美观并且一致，这里写下这份Swift编程规范指南。该指南首要目标是让代码紧凑，可读性更高且简洁。&lt;/p&gt;
&lt;h2 id=&quot;代码格式&quot;&gt;&lt;a href=&quot;#代码格式&quot; class=&quot;headerlink&quot; title=&quot;代码格式&quot;&gt;&lt;/a&gt;代码格式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用四个空格进行缩进&lt;/li&gt;
&lt;li&gt;每行最多160个字符，这样可以避免一行过长（Xcode-&amp;gt;Preferences-&amp;gt;Text Editing-&amp;gt;Page guide at column: 设置成160即可）&lt;/li&gt;
&lt;li&gt;确保每个文件结尾都有空白行&lt;/li&gt;
&lt;li&gt;确保每行都不以空白符作为结尾（Xcode-&amp;gt;Preferences-&amp;gt;Text Editing-&amp;gt;Automatically trim trailing whitespace + Including whitespace-only lines）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左大括号不用另起一行&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;someMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x == y &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x == z &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要在逗号后面加空格&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; array = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="cocoaPods" scheme="http://yoursite.com/tags/cocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>小公司如何谈服务器安全</title>
    <link href="http://yoursite.com/2016/10/08/%E5%B0%8F%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E8%B0%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2016/10/08/小公司如何谈服务器安全/</id>
    <published>2016-10-08T08:59:37.000Z</published>
    <updated>2018-03-01T05:49:39.754Z</updated>
    
    <content type="html"><![CDATA[<p>经常会被一些客户问到服务器的安全是怎么考虑的，对于这个问题，我心中总是会默默地在说：你们考虑得太多了，你们的目前还不需要考虑这么多，把放在这个问题上的心思放在自己的业务上吧，如何去思考怎么运营好现在的业务再说。但是还是一脸正经地说一堆书上的东西，书上写的东西的可操作性却是另外一件事情了。</p><blockquote><p>那作为小公司创业，应该如何保护好自己的服务器，如何最小的成本去谈安全呢？</p></blockquote><p>小公司业务不多的情况下，服务器的安全主要分为两类，一类是代码与数据安全，一类是运维层面上的。<br><a id="more"></a></p><h2 id="代码安全"><a href="#代码安全" class="headerlink" title="代码安全"></a>代码安全</h2><ol><li>关键接口做访问限制，对于单个用户，访问同一个接口做访问限制</li><li>常规SQL注入检查</li><li>如果有需要，可以做关键代码的加密混淆（后台采用的是PHP）</li></ol><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><ol><li>数据库的安全，尽量使用云提供的解决方案，单独购买Mysql实例，SSD硬盘，全方位提供部署主备架构且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案。采用mysql实例可以减少很多数据库运维工作，如果没有的，就需要自己做一主一从一备，开启binlog日志，每天全备一次。</li><li>文件（照片，文档）采用第三方存储，像阿里云存储、七牛存储。</li></ol><h2 id="运维层次"><a href="#运维层次" class="headerlink" title="运维层次"></a>运维层次</h2><ol><li>只开放需要的端口</li><li>修改SSH端口，使用证书登录，或者限制IP登录</li><li>关注Linux漏洞，及时打补丁</li><li>做好硬件防火墙</li></ol><p>现在云基本上都提供常见的安全服务，做好监控报警机制就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常会被一些客户问到服务器的安全是怎么考虑的，对于这个问题，我心中总是会默默地在说：你们考虑得太多了，你们的目前还不需要考虑这么多，把放在这个问题上的心思放在自己的业务上吧，如何去思考怎么运营好现在的业务再说。但是还是一脸正经地说一堆书上的东西，书上写的东西的可操作性却是另外一件事情了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那作为小公司创业，应该如何保护好自己的服务器，如何最小的成本去谈安全呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小公司业务不多的情况下，服务器的安全主要分为两类，一类是代码与数据安全，一类是运维层面上的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jenkins+Cocoapods+Coding+Git+Fir iOS项目持续集成</title>
    <link href="http://yoursite.com/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS%E9%A1%B9%E7%9B%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/</id>
    <published>2016-08-04T10:23:00.000Z</published>
    <updated>2018-03-01T05:49:39.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p></blockquote><h3 id="为什么使用持续集成"><a href="#为什么使用持续集成" class="headerlink" title="为什么使用持续集成"></a>为什么使用持续集成</h3><p>1、减少重复繁琐的打包过程<br>2、任何时间、任何地点测试都可以获取到新包<br>3、增强项目的可见性</p><p>做持续集成对我们开发者来说是一件一劳永益的事情，对于发包这个问题，相信是每个程序员GG心中挥之不去的痛，而测试MM们也在每次马上就发出来的承诺中得出一个结论就是“你是个大骗子”。</p><p>所以每次被测试MM追着要包，产品经理说给我装一个新包瞧瞧呗，后台GG说给我装一个老版本调试一下啊。。。这个时候我们的内心是奔溃的，然后我们不得不暂停手下的工作，切换到某个版本，Archive。。。其实对于打包发包这种事情根本就不是开发需要做的，因为这是一个简单没有技术含量且浪费时间的工作。时间就是金钱，所以为了不再浪费我们开发宝贵的时间，自动化构建这件事情必须得提上日程了。</p><a id="more"></a><h3 id="常见的持续集成工具"><a href="#常见的持续集成工具" class="headerlink" title="常见的持续集成工具"></a>常见的持续集成工具</h3><ul><li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins CI</a></li><li><a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a></li><li><a href="http://hudson-ci.org/" target="_blank" rel="noopener">Hudson CI</a></li><li><a href="https://circleci.com/" target="_blank" rel="noopener">Circle CI</a></li></ul><p>持续集成的工具有很多，不过最好用的还是Jenkins，Travis能够对Github上的开源项目做很好的集成，考虑到Jenkins的稳定性，我们还是选择Jenkins来开始我的iOS持续集成。</p><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>本事例项目工程代码存放在coding，使用Cocoapods管理第三方库，存在在coding上的项目目录结构如下：<br><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/coding.png" title="目录结构图"><br>由于cocoapods文件过多，所以没有必要上传到git仓库中，只用将Podfile文件传上去即可。</p><h3 id="Jenkins的安装"><a href="#Jenkins的安装" class="headerlink" title="Jenkins的安装"></a>Jenkins的安装</h3><p>由于Jenkins是Java开发的，所以首先我们需要先安装好Java环境，然后去Jenkins的<a href="http://jenkins-ci.org/" target="_blank" rel="noopener">官网</a>下载最新的war包。下载完成后，打开终端，进入到war包所在目录，执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jenkins.war --httpPort=8888</span><br></pre></td></tr></table></figure></p><p>httpPort指的就是Jenkins所使用的http端口，这里指定8888，可根据具体情况来修改。待Jenkins启动后，在浏览器页面输入以下地址:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888</span><br></pre></td></tr></table></figure></p><p>这样就可以打开Jenkins页面了。</p><blockquote><p><code>--httpPort=8888</code>可以不输入，不输入默认端口号为8080</p></blockquote><p>打开链接后，先要设置一些安装信息，这里就不再啰嗦，因为十分简单，接下来我们来看安装成功后的相关配置。</p><h3 id="Jenkins的配置"><a href="#Jenkins的配置" class="headerlink" title="Jenkins的配置"></a>Jenkins的配置</h3><p>到Jenkins页面，Jenkins－系统管理－插件管理－可选插件中，安装一下插件：</p><ul><li>GIT plugin</li><li>Git client plugin</li><li>Xcode integration</li><li>CocoaPods Jenkins Integration</li></ul><h4 id="Git私有仓库配置"><a href="#Git私有仓库配置" class="headerlink" title="Git私有仓库配置"></a>Git私有仓库配置</h4><p>按照如下方式添加SSH，因为项目代码是存放在coding上的所以，这个关于生成SSH可以以Coding为例：<a href="https://coding.net/help/doc/git/ssh-key.html" target="_blank" rel="noopener">https://coding.net/help/doc/git/ssh-key.html</a></p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/ssh_username_private_key.png" title="SSH 秘钥配置"><h4 id="创建Job"><a href="#创建Job" class="headerlink" title="创建Job"></a>创建Job</h4><p>这里的步骤我准备全部一图片的形式展示出来。</p><p>点击“Jenkins”－“新建”：</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/new_job.png" title="创建Job"><h4 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p>选择刚刚创建的项目，点击“配置”：</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/set_code_source.png" title="设置源码地址"><p>这里最好使用SSH，这个工程是私有项目，如果出现错误肯定是由你自己配置错误造成的。</p><h4 id="构建步骤设置"><a href="#构建步骤设置" class="headerlink" title="构建步骤设置"></a>构建步骤设置</h4><p>选择构建步骤，记得添加Xcode插件，选择添加Execute Shell和Xcode，有先后顺序。</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/execte_config.png" title="添加构建步骤"><p>设置Execute Shell</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/execute_shell.png" title="Execute Shell"><h4 id="Xcode-General-build-settings"><a href="#Xcode-General-build-settings" class="headerlink" title="Xcode General build settings"></a>Xcode General build settings</h4><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/xcode_general_build_settings.png" title="General build settings"><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/code_signing_OS_X_keychain_options.png" title="Code signing & OS X keychain options"><p>Keychain path填写<code>${HOME}/Library/Keychains/login.keychain</code><br>Keychain password对应的密码可以在钥匙串中查看：</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/keychain.png" title="Code signing & OS X keychain password查看方法"><h4 id="Advanced-Xcode-build-options"><a href="#Advanced-Xcode-build-options" class="headerlink" title="Advanced Xcode build options"></a>Advanced Xcode build options</h4><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/xcode_build_options.png" title="Advanced Xcode build options"><h3 id="fir-im-Jenkins-插件安装"><a href="#fir-im-Jenkins-插件安装" class="headerlink" title="fir.im Jenkins 插件安装"></a>fir.im Jenkins 插件安装</h3><p>上面的构建配置好了后，如果顺利的话就已经能够编译出ipa文件了，但是编译出来的ipa只能放在本地，不能给大家安装，所以编译完成后我们还需要将ipa文件上传到fir.im。<br>fir插件的安装方法详情请移步：<a href="http://blog.fir.im/jenkins/" target="_blank" rel="noopener">《fir.im Jenkins 插件使用方法》</a></p><h3 id="构建后上传到fir-im"><a href="#构建后上传到fir-im" class="headerlink" title="构建后上传到fir.im"></a>构建后上传到fir.im</h3><p>安装好fir插件后在“构建后操作”中点击“添加构建后操作步骤”，可以看到：</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/upload_fir.png" title="添加构建后上传fir步骤"><p>点击“upload to fir.im”，然后会出现如下界面：</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/set_upload_fir.png" title="设置fir.im的Token"><p>Fir.im的Token获取地址：<a href="http://fir.im/apps/apitoken" target="_blank" rel="noopener">http://fir.im/apps/apitoken</a></p><h3 id="手动构建"><a href="#手动构建" class="headerlink" title="手动构建"></a>手动构建</h3><p>选中你要构建的项目，然后点击“立即构建”</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/shoudong_goujian.png" title="手动构建"><p>选择正在构建的Build，然后点击“Console Output”可以查看build过程中打印的一些信息，如果遇到什么报错信息都可以在这里面查看。</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/build_message.png" title="控制台输出"><h3 id="自动构建设置"><a href="#自动构建设置" class="headerlink" title="自动构建设置"></a>自动构建设置</h3><p>构建触发器有一下几种触发方式：</p><ul><li>触发远程构建 (例如,使用脚本)</li><li>Build after other projects are built</li><li>Build periodically</li><li>Poll SCM</li></ul><p>这里我只用到了Build periodically</p><img src="/2016/08/04/Jenkins-Cocoapods-Coding-Git-Fir-iOS项目持续集成/zidong_goujian.png" title="Build periodically触发自动构建"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了搭建这个Jenkins我看了很多博客，不过大多比较难懂，一直都没有成功，经过各种尝试后最终搭建成功，我在此将整个过程记录下来，以来是对自己知识的一个积累，二来如果能够给将要搭建Jenkins的iOS持续集成的朋友们一点帮助也是极好的。</p><p>参考文档：<br><a href="http://www.jianshu.com/p/c69deb29720d#" target="_blank" rel="noopener">一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP</a><br><a href="http://rannie.github.io/ios/2014/12/29/xcodebuild-jenkins-ci.html" target="_blank" rel="noopener">使用 Xcodebuild + Jenkins + Apache 做 iOS 持续集成</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么使用持续集成&quot;&gt;&lt;a href=&quot;#为什么使用持续集成&quot; class=&quot;headerlink&quot; title=&quot;为什么使用持续集成&quot;&gt;&lt;/a&gt;为什么使用持续集成&lt;/h3&gt;&lt;p&gt;1、减少重复繁琐的打包过程&lt;br&gt;2、任何时间、任何地点测试都可以获取到新包&lt;br&gt;3、增强项目的可见性&lt;/p&gt;
&lt;p&gt;做持续集成对我们开发者来说是一件一劳永益的事情，对于发包这个问题，相信是每个程序员GG心中挥之不去的痛，而测试MM们也在每次马上就发出来的承诺中得出一个结论就是“你是个大骗子”。&lt;/p&gt;
&lt;p&gt;所以每次被测试MM追着要包，产品经理说给我装一个新包瞧瞧呗，后台GG说给我装一个老版本调试一下啊。。。这个时候我们的内心是奔溃的，然后我们不得不暂停手下的工作，切换到某个版本，Archive。。。其实对于打包发包这种事情根本就不是开发需要做的，因为这是一个简单没有技术含量且浪费时间的工作。时间就是金钱，所以为了不再浪费我们开发宝贵的时间，自动化构建这件事情必须得提上日程了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>代码规范之程序员必须知道的命名规范</title>
    <link href="http://yoursite.com/2016/07/05/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2016/07/05/代码规范之程序员必须知道的命名规范/</id>
    <published>2016-07-05T07:52:03.000Z</published>
    <updated>2018-03-01T05:49:39.754Z</updated>
    
    <content type="html"><![CDATA[<p>代码规范中最重要同样也是最重要的规范应该就是代码规范了吧。代码中到处都需要命名，作为程序员我们可能常常会为一些变量、常量、函数等命名而烦恼。下面有一些关于命名的注意事项，它可以帮助我们提高命名的能了，使我们的代码更具有可读性。</p><h2 id="使用能够表达意图的名字"><a href="#使用能够表达意图的名字" class="headerlink" title="使用能够表达意图的名字"></a>使用能够表达意图的名字</h2><p>名字得能告诉我们它要做什么，为什么存在，以及是如何工作的。选择能够表达意图的名字，将更有利于我们理解代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d; <span class="comment">// elapsed time in days</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> elapsedTimeInDays;</span><br><span class="line"><span class="keyword">int</span> daysSinceCreation;</span><br><span class="line"><span class="keyword">int</span> daysSinceModification;</span><br><span class="line"><span class="keyword">int</span> fileAgeInDays;</span><br></pre></td></tr></table></figure><p>在上面的片段中，我们只能从注释中知道变量d指的是什么。于是阅读代码的人为了知道它的含义就不得不去寻找它的实例以获取线索。所以，要是我们能够好好命名这个变量，阅读代码的人就能够瞬间知道这变量的含义。<br><a id="more"></a></p><h2 id="不要怕在选择名字上花时间"><a href="#不要怕在选择名字上花时间" class="headerlink" title="不要怕在选择名字上花时间"></a>不要怕在选择名字上花时间</h2><p>你应该多试几种不同的名字，直至足以描述其含义，千万不要害怕在这上面花时间。以后阅读你代码的人（包括你自己）将会因此而受益。此外，一个描述性的名称甚至还能有助于你在心中理清模块的设计。良好的命名的确需要花费时间，但是从长远来看，利大于弊。</p><h2 id="重构名字"><a href="#重构名字" class="headerlink" title="重构名字"></a>重构名字</h2><p>如果你在后面的开发过程中想到了一个更好的名字，那就不要犹豫，马上去改吧。现在的IDE使得重构名字变得异常容易。</p><h2 id="避免在名字中出现干扰词"><a href="#避免在名字中出现干扰词" class="headerlink" title="避免在名字中出现干扰词"></a>避免在名字中出现干扰词</h2><p>比如Manager、Processor、Data、Info以及“我不知道这叫什么”的同义词，都是干扰词。如果你需要使用上面这些干扰词的话，那么说明你的命名可能太累赘了。</p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>类应该有个名词或名词词组的名字，如<code>Customer</code>、<code>WikiPage</code>、<code>Account</code>和<code>AddressParser</code>。继承性父类应该给个又短又有冲击力的名字。子类的名字应该长点，通过形容词来描述其不同于它的父类之处，如<code>SavingsAccount</code>衍生于<code>Account</code>。</p><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>变量名也应该是名词。它们大多是由其指向的类衍生出去的。布尔变量应写成谓词的形式，如<code>isEmpty</code>和<code>isTerminated</code>，这样放到<code>if</code>语句才便于理解。</p><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p>方法名应该是一个动词或动词词组，如<code>postPayment()</code>、<code>deletePage()</code>和<code>save()</code>。访问器和调整器应该分别前缀<code>get</code>和<code>set</code>。返回布尔值的方法应该前缀‘is’，如<code>isPostable()</code>，这样在<code>if</code>语句中才便于理解。</p><h2 id="范围大小与变量名的长度"><a href="#范围大小与变量名的长度" class="headerlink" title="范围大小与变量名的长度"></a>范围大小与变量名的长度</h2><p>变量名的长度应和它的范围大小相匹配。如果变量的范围很短，那么变量名的长度也应该很短。反之，变量名则应该长一点，更有描述性。</p><h2 id="范围大小与方法-类名的长度"><a href="#范围大小与方法-类名的长度" class="headerlink" title="范围大小与方法/类名的长度"></a>范围大小与方法/类名的长度</h2><p>对于方法和类名的长度则应该与其范围成反比。对于公共方法，短一点的名字会比较好，这是因为它们会被调用多次。私有方法只在类的范围内被调用，长一点的名字反而可以作为文档使用。此条规则的例外是派生类的名字。类越派生，基类前所加的形容词就越多，名字也就越长。</p><h2 id="一个概念一个词"><a href="#一个概念一个词" class="headerlink" title="一个概念一个词"></a>一个概念一个词</h2><p>为某个抽象概念选定一个词，然后就不要变了。例如作为不同类中的等效方法，<code>get()</code>、<code>fetch()</code>和<code>retrieve()</code>会让人混淆起来。保持一致的词汇是程序员驾驭代码的重要工具。</p><h2 id="不要将同一个词用于两个不同的概念"><a href="#不要将同一个词用于两个不同的概念" class="headerlink" title="不要将同一个词用于两个不同的概念"></a>不要将同一个词用于两个不同的概念</h2><p>如果你遵循上一点一个概念一个词的原则，那么就可以避免许多有着相同方法名的类。只要参数列表和各种方法的返回值在语义上是等价的就没问题。只有当你将同一个词用于两个不同的概念时才会出现问题。</p><p>例如，我们可以在多个类中使用<code>add()</code>方法，通过添加或连接两个现有的值来创建一个新的值。如果我们之后又需要在类中引入一个<code>add</code>方法用于添加参数到集合中，这就会因为语义不同而导致问题。这种新方法最好是改叫为<code>insert()</code>。</p><h2 id="使用解决方案领域的名字"><a href="#使用解决方案领域的名字" class="headerlink" title="使用解决方案领域的名字"></a>使用解决方案领域的名字</h2><p>我们编写的代码今后可能会有其他程序员来阅读，所以我们使用一些技术术语进行代码命名会带来很大的好处。比如适当地使用算法名字、设计模式名字以及数学术语，这些命名方式很可能会让其他程序员更容易理解程序，引起共鸣。</p><h2 id="使用问题领域的名字"><a href="#使用问题领域的名字" class="headerlink" title="使用问题领域的名字"></a>使用问题领域的名字</h2><p>如果实在找不到易于理解的技术术语来命名，那么也可以从问题领域来寻找合适的代码命名。当未来阅读你代码的程序员不确定代码意义的时候，这将为他们提供一些问题的线索。</p><h2 id="添加有意义的语境"><a href="#添加有意义的语境" class="headerlink" title="添加有意义的语境"></a>添加有意义的语境</h2><p>大多数名字其本身是没有意义的，并且需要放到语境（类/函数/命名空间）中，才能让阅读代码的人理解它们指代的是什么。在某些情况下，可能需要前缀名称以补充语境。例如，假设我们有一些用来表示地址的变量：<code>firstName</code>、<code>lastName</code>、<code>street</code>、<code>houseNumber</code>、<code>city</code>、<code>state</code>和<code>zip</code>。如果只看<code>state</code>这个变量，我们是很难推断出它指的是什么意思，一个比较好的解决办法就是将这些变量封装到<code>Address</code>类中。</p><h2 id="不要添加没来由的语境"><a href="#不要添加没来由的语境" class="headerlink" title="不要添加没来由的语境"></a>不要添加没来由的语境</h2><p>只要意思明确，短一点的名字通常比长的好，所以不要多此一举地添加语境。名字前不应该被加缀一些可以从类/包/命名空间中推断的不必要的信息。</p><h2 id="避免编码"><a href="#避免编码" class="headerlink" title="避免编码"></a>避免编码</h2><p>鉴于现在的IDE的强大，我们已经不需要编码类型和范围信息到变量名和类名中。这包括不必添加I至接口，因为使用代码的用户不需要知道他们的类正在向接口传递。所以如果你一定要使用编码，那么最好是对实现进行编码而不是接口。</p><h2 id="避免错误的信息"><a href="#避免错误的信息" class="headerlink" title="避免错误的信息"></a>避免错误的信息</h2><p>不要给一些错误的信息，因为这样会误导阅读代码的人。如果你将一个实际支持数组的变量命名为<code>accountList</code>，那就很容易让人得出错误的结论。<code>accountList</code>应该命名为<code>accounts</code>会好一点。</p><h2 id="使用读不出来的名字"><a href="#使用读不出来的名字" class="headerlink" title="使用读不出来的名字"></a>使用读不出来的名字</h2><p>编程是一个社会化的活动，使用那些读不出来的名字只会阻碍我们的讨论。</p><h2 id="使用易搜索的名字"><a href="#使用易搜索的名字" class="headerlink" title="使用易搜索的名字"></a>使用易搜索的名字</h2><p>使用短而通用的名字会妨碍我们在代码库中搜索事物。这对我们操纵代码和重构很有影响。</p><p>最后还有什么相关的建议，欢迎大家一起讨论</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码规范中最重要同样也是最重要的规范应该就是代码规范了吧。代码中到处都需要命名，作为程序员我们可能常常会为一些变量、常量、函数等命名而烦恼。下面有一些关于命名的注意事项，它可以帮助我们提高命名的能了，使我们的代码更具有可读性。&lt;/p&gt;
&lt;h2 id=&quot;使用能够表达意图的名字&quot;&gt;&lt;a href=&quot;#使用能够表达意图的名字&quot; class=&quot;headerlink&quot; title=&quot;使用能够表达意图的名字&quot;&gt;&lt;/a&gt;使用能够表达意图的名字&lt;/h2&gt;&lt;p&gt;名字得能告诉我们它要做什么，为什么存在，以及是如何工作的。选择能够表达意图的名字，将更有利于我们理解代码。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; d; &lt;span class=&quot;comment&quot;&gt;// elapsed time in days&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; elapsedTimeInDays;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; daysSinceCreation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; daysSinceModification;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fileAgeInDays;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的片段中，我们只能从注释中知道变量d指的是什么。于是阅读代码的人为了知道它的含义就不得不去寻找它的实例以获取线索。所以，要是我们能够好好命名这个变量，阅读代码的人就能够瞬间知道这变量的含义。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS代码规范</title>
    <link href="http://yoursite.com/2016/07/05/JS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2016/07/05/JS代码规范/</id>
    <published>2016-07-05T07:41:19.000Z</published>
    <updated>2018-03-01T05:49:39.720Z</updated>
    
    <content type="html"><![CDATA[<p>ESlint：ECMAScript/JavaScript代码的分析工具，根据编写的规则检测代码语法和风格错误</p><ul><li>规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用；</li><li>包含代码风格检测的规则；</li><li>支持插件扩展、自定义规则。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过npm安到本地node_modules</p><pre><code>cd到工程目录npm i --save-dev eslint eslint-plugin-react eslint-plugin-react-native</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>cd到工程目录创建或导入配置文件：eslint --init开始分析代码：eslint test.js test2.js或eslint 目录/</code></pre><a id="more"></a><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>主要有两种配置方式：</p><ul><li>直接在代码文件中配置</li><li>通过配置文件配置</li></ul><p><a href="http://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">http://eslint.org/docs/user-guide/configuring</a></p><h4 id="1-直接在代码文件中配置"><a href="#1-直接在代码文件中配置" class="headerlink" title="1.直接在代码文件中配置"></a>1.直接在代码文件中配置</h4><p>禁用 ESLint：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* eslint-disable */</span><br><span class="line">var obj = &#123; key: <span class="string">'value'</span>, &#125;; // I don<span class="string">'t care about IE8  </span></span><br><span class="line"><span class="string">/* eslint-enable */</span></span><br></pre></td></tr></table></figure><p>禁用一条规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*eslint-disable no-alert */</span><br><span class="line">alert(<span class="string">'doing awful things'</span>);  </span><br><span class="line">/* eslint-enable no-alert */</span><br></pre></td></tr></table></figure><p>调整规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* eslint no-comma-dangle:1 */</span><br><span class="line">// Make this just a warning, not an error</span><br><span class="line">var obj = &#123; key: <span class="string">'value'</span>, &#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过配置文件配置"><a href="#2-通过配置文件配置" class="headerlink" title="2.通过配置文件配置"></a>2.通过配置文件配置</h4><p>可在 .eslintrc.* 文件或package.json中添加eslintConfig模块配置<br>eslinttrc可以识别的文件：</p><ol><li>.eslintrc.js</li><li>.eslintrc.yaml</li><li>.eslintrc.yml</li><li>.eslintrc.json</li><li>.eslintrc</li><li>package.json</li></ol><p>注：当同一目录包含多个以上文件时，eslint只会使用其中一个，使用顺序是上面从上往下。当你在根目录下分析代码时，eslint会使用根目录下的.eslintrc.*当切换到子目录下分析代码时，eslint会使用子目录下的.eslintrc.*</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">/* eslint-disable */</span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"es6"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"node"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,//定义使用环境</span><br><span class="line"></span><br><span class="line">  // extends: <span class="string">'airbnb'</span>,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">'react'</span>,</span><br><span class="line">    <span class="string">'react-native'</span>,</span><br><span class="line">  ],//规则插件</span><br><span class="line"></span><br><span class="line">  <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"ecmaFeatures"</span>: &#123;</span><br><span class="line">      <span class="string">"jsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,//指定附加的语法特性</span><br><span class="line">    <span class="string">"sourceType"</span>: <span class="string">"module"</span>//默认为<span class="string">"script"</span>，如果使用ECMAScript模块，设置为<span class="string">"module"</span></span><br><span class="line">  &#125;,//指定分析器支持选项</span><br><span class="line"></span><br><span class="line">  <span class="string">"globals"</span>: &#123;</span><br><span class="line">        <span class="string">"var1"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"var2"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    //react-native插件规则</span><br><span class="line">    <span class="string">"react-native/no-unused-styles"</span>: <span class="string">"error"</span>,</span><br><span class="line">    <span class="string">"react-native/split-platform-components"</span>: <span class="string">"error"</span>,</span><br><span class="line">    <span class="string">"react-native/no-inline-styles"</span>: <span class="string">"error"</span>,</span><br><span class="line">    // <span class="string">"react-native/no-color-literals"</span>: <span class="string">"error"</span>,</span><br><span class="line"></span><br><span class="line">    //容易出错的</span><br><span class="line">    <span class="string">"no-cond-assign"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],//x=0不再是有效布尔表达式</span><br><span class="line">    <span class="string">"no-console"</span>: <span class="string">"error"</span>,//禁用控制台输出</span><br><span class="line">    <span class="string">"no-constant-condition"</span>: <span class="string">"error"</span>,//判断和循环的布尔表达式，禁用常量表达式</span><br><span class="line">    <span class="string">"no-dupe-args"</span>: <span class="string">"error"</span>,//禁止方法有相同参数名</span><br><span class="line">    <span class="string">"no-dupe-keys"</span>: <span class="string">"error"</span>,//禁止对象有相同属性名</span><br><span class="line">    <span class="string">"no-duplicate-case"</span>: <span class="string">"error"</span>,//禁止switch中有相同的<span class="keyword">case</span></span><br><span class="line">    <span class="string">"no-empty"</span>: <span class="string">"error"</span>,//禁止空的块声明</span><br><span class="line">    <span class="string">"no-extra-semi"</span>: <span class="string">"error"</span>,//去除多余的分号,比如“;;”</span><br><span class="line">    <span class="string">"no-func-assign"</span>: <span class="string">"error"</span>,//禁止重定义方法</span><br><span class="line">    <span class="string">"no-inner-declarations"</span>: <span class="string">"error"</span>,//禁止在块中定义方法</span><br><span class="line">    <span class="string">"no-invalid-regexp"</span>: <span class="string">"error"</span>,//禁止错误的正则表达式</span><br><span class="line">    <span class="string">"no-irregular-whitespace"</span>: <span class="string">"error"</span>,//禁止不合法空格</span><br><span class="line">    <span class="string">"no-obj-calls"</span>: <span class="string">"error"</span>,//禁止Math()、JSON()等，应为它们本来就是object</span><br><span class="line">    <span class="string">"no-prototype-builtins"</span>: <span class="string">"error"</span>,//禁止 var hasBarProperty = foo.hasOwnProperty(<span class="string">"bar"</span>);应该 var hasBarProperty = &#123;&#125;.hasOwnProperty.call(foo, <span class="string">"bar"</span>);</span><br><span class="line">    <span class="string">"no-regex-spaces"</span>: <span class="string">"error"</span>,//正则表达式禁止连续空格/foo   bar/应该是/foo &#123;3&#125;bar/</span><br><span class="line">    <span class="string">"no-sparse-arrays"</span>: <span class="string">"error"</span>,//禁止[,]，[ <span class="string">"red"</span>,, <span class="string">"blue"</span> ]这种不插入元素行为</span><br><span class="line">    <span class="string">"no-unreachable"</span>: <span class="string">"error"</span>,//禁止在<span class="built_in">return</span>, throw, <span class="built_in">break</span>, and <span class="built_in">continue</span>后的可能执行不到的代码，比如&#123;x = 1;<span class="built_in">return</span> x;&#125;,而&#123;<span class="built_in">return</span> x；x = 1;&#125;可以</span><br><span class="line">    <span class="string">"no-unsafe-finally"</span>: <span class="string">"error"</span>,//禁止在finally中使用<span class="built_in">return</span>, throw, <span class="built_in">break</span>, or <span class="built_in">continue</span></span><br><span class="line">    <span class="string">"use-isnan"</span>: <span class="string">"error"</span>,//禁止 foo == NaN，应该 isNaN(foo)</span><br><span class="line">    <span class="string">"valid-typeof"</span>: <span class="string">"error"</span>,//禁止不合法的 typeof，http://eslint.org/docs/rules/valid-typeof</span><br><span class="line">    // <span class="string">"valid-jsdoc"</span>: <span class="string">"error"</span>,//强制添加JSDoc方法说明</span><br><span class="line">    // <span class="string">"no-unexpected-multiline"</span>: <span class="string">"error"</span></span><br><span class="line">    // <span class="string">"no-debugger"</span>: <span class="string">"error"</span>//禁用debugger语句</span><br><span class="line"></span><br><span class="line">    //好的习惯</span><br><span class="line">    // <span class="string">"accessor-pairs"</span>: <span class="string">"error"</span>,//强制属性添加 getter/setter</span><br><span class="line">    <span class="string">"array-callback-return"</span>: <span class="string">"error"</span>,//强制array的迭代回调函数有<span class="built_in">return</span></span><br><span class="line">    // <span class="string">"block-scoped-var"</span>: <span class="string">"error"</span>,//禁止在局域块中声明变量</span><br><span class="line">    // <span class="string">"complexity"</span>: [<span class="string">"error"</span>, 2],//限制控制语句的最大级数</span><br><span class="line">    // <span class="string">"consistent-return"</span>: <span class="string">"error"</span>,//禁止空<span class="built_in">return</span></span><br><span class="line">    <span class="string">"curly"</span>: <span class="string">"error"</span>,//禁止 <span class="keyword">if</span> (foo) foo++;等，必须 <span class="keyword">if</span> (foo) &#123;foo++;&#125;</span><br><span class="line">    <span class="string">"default-case"</span>: <span class="string">"error"</span>,//switch必须要有default</span><br><span class="line">    <span class="string">"dot-notation"</span>: <span class="string">"error"</span>,//禁止 foo[<span class="string">"bar"</span>]，通过 foo.bar或 foo[bar]</span><br><span class="line">    <span class="string">"eqeqeq"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],//禁止用“==”, “!=”, 用“===”和“!==”</span><br><span class="line">    <span class="string">"no-case-declarations"</span>: <span class="string">"error"</span>,//<span class="keyword">case</span>/default后必须加“&#123;&#125;”构成块</span><br><span class="line">    <span class="string">"no-div-regex"</span>: <span class="string">"error"</span>,//不允许有分歧的正则表达式</span><br><span class="line">    <span class="string">"no-empty-function"</span>: <span class="string">"error"</span>,//禁止空方法</span><br><span class="line">    <span class="string">"no-empty-pattern"</span>: <span class="string">"error"</span>,//禁止空解构赋值</span><br><span class="line">    <span class="string">"no-eq-null"</span>: <span class="string">"error"</span>,//只能使用“===”判断null，因为使用 foo == null，foo为undefined也会通过</span><br><span class="line">    <span class="string">"no-extra-bind"</span>: <span class="string">"error"</span>,//禁止不必要的<span class="built_in">bind</span>()</span><br><span class="line">    <span class="string">"no-fallthrough"</span>: <span class="string">"error"</span>,//不允许忘了加 <span class="built_in">break</span></span><br><span class="line">    <span class="string">"no-invalid-this"</span>: <span class="string">"error"</span>,//不允许this关键字在class域之外出现</span><br><span class="line">    <span class="string">"no-loop-func"</span>: <span class="string">"error"</span>,//禁止在循环中定义函数</span><br><span class="line">    // <span class="string">"no-magic-numbers"</span>: <span class="string">"warn"</span>,//magic-numbers应该消失了</span><br><span class="line">    <span class="string">"no-new-wrappers"</span>: <span class="string">"error"</span>,//禁止对 String, Number, Boolean 使用new</span><br><span class="line">    <span class="string">"no-new-func"</span>: <span class="string">"error"</span>,//禁止对func使用new</span><br><span class="line">    <span class="string">"no-param-reassign"</span>: <span class="string">"error"</span>,//禁止给函数参数再赋值</span><br><span class="line">    <span class="string">"no-redeclare"</span>: <span class="string">"error"</span>,//不可以重定义变量</span><br><span class="line">    <span class="string">"no-return-assign"</span>: <span class="string">"error"</span>,//<span class="built_in">return</span> foo = bar + 2;赋值是多余的，要么<span class="built_in">return</span> bar + 2;要么<span class="built_in">return</span> foo === bar + 2;</span><br><span class="line">    <span class="string">"no-self-assign"</span>: <span class="string">"error"</span>,//禁止foo = foo;</span><br><span class="line">    <span class="string">"no-self-compare"</span>: <span class="string">"error"</span>,//禁止x === x</span><br><span class="line">    <span class="string">"no-unused-expressions"</span>: <span class="string">"error"</span>,//不要有无用表达式</span><br><span class="line"></span><br><span class="line">    //strict模式</span><br><span class="line">    // <span class="string">"strict"</span>: [<span class="string">"error"</span>, <span class="string">"global"</span>]</span><br><span class="line"></span><br><span class="line">    //关于变量</span><br><span class="line">    <span class="string">"init-declarations"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],//强制初始化变量</span><br><span class="line">    <span class="string">"no-undef"</span>: [<span class="string">"warn"</span>, &#123; <span class="string">"typeof"</span>: <span class="literal">true</span>&#125;],//禁止未定义变量</span><br><span class="line">    <span class="string">"no-unused-vars"</span>: <span class="string">"warn"</span>,//未使用变量</span><br><span class="line">    // <span class="string">"no-use-before-define"</span>: <span class="string">"error"</span>,//不能先使用后定义变量</span><br><span class="line"></span><br><span class="line">    //编程风格</span><br><span class="line">    <span class="string">"comma-dangle"</span>: [<span class="string">"error"</span>, <span class="string">"never"</span>],//只在元素间加逗号</span><br><span class="line">    <span class="string">"array-bracket-spacing"</span>: [<span class="string">"error"</span>, <span class="string">"never"</span>],//方括号内无空格</span><br><span class="line">    <span class="string">"block-spacing"</span>: <span class="string">"error"</span>,//block内部空格 &#123; <span class="built_in">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="string">"brace-style"</span>: <span class="string">"error"</span>,//http://eslint.org/docs/rules/brace-style</span><br><span class="line">    <span class="string">"camelcase"</span>: [<span class="string">"warn"</span>, &#123;properties: <span class="string">"never"</span>&#125;],//驼峰命名,除对象属性外</span><br><span class="line">    <span class="string">"comma-spacing"</span>: [<span class="string">"error"</span>, &#123; <span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">true</span> &#125;],//“,”后要有空</span><br><span class="line">    <span class="string">"comma-style"</span>: [<span class="string">"error"</span>, <span class="string">"last"</span>],//“,”只能打在末尾</span><br><span class="line">    <span class="string">"computed-property-spacing"</span>: [<span class="string">"error"</span>, <span class="string">"never"</span>],//属性取值无空格，不要obj[ foo ]，应该obj[foo]</span><br><span class="line">    <span class="string">"consistent-this"</span>: [<span class="string">"error"</span>, <span class="string">"self"</span>],//this只能赋值给名为self的变量</span><br><span class="line">    <span class="string">"eol-last"</span>: <span class="string">"error"</span>,//代码结束于新的一行</span><br><span class="line">    <span class="string">"indent"</span>: [<span class="string">"error"</span>, 2],//2空格缩进</span><br><span class="line">    <span class="string">"key-spacing"</span>: [<span class="string">"error"</span>, &#123; <span class="string">"beforeColon"</span>: <span class="literal">false</span> &#125;],//键值对“:”后必须加一个空格</span><br><span class="line">    <span class="string">"keyword-spacing"</span>: [<span class="string">"error"</span>, &#123; <span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">true</span> &#125;],//关键字前无空格，关键字后有空格</span><br><span class="line">    <span class="string">"object-curly-newline"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],//悬挂式定义对象</span><br><span class="line">    <span class="string">"quote-props"</span>: [<span class="string">"error"</span>, <span class="string">"as-needed"</span>, &#123; <span class="string">"numbers"</span>: <span class="literal">true</span> &#125;],//属性名无引号</span><br><span class="line">    // <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>],//双引号</span><br><span class="line">    <span class="string">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],//必须分号</span><br><span class="line">    <span class="string">"space-before-blocks"</span>: <span class="string">"error"</span>,//<span class="string">"&#123;"</span>前面必须加空格</span><br><span class="line">    <span class="string">"space-infix-ops"</span>: <span class="string">"error"</span>,//运算符之间加空格</span><br><span class="line"></span><br><span class="line">    //更多规则查看：http://eslint.org/docs/rules/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-集成"><a href="#4-集成" class="headerlink" title="4.集成"></a>4.集成</h3><h4 id="atom集成"><a href="#atom集成" class="headerlink" title="atom集成"></a>atom集成</h4><p>安装linter, 安装linter-eslint:是eslint到linter的接口，eslint分析代码，linter将分析结果显示在atom中</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ESlint：ECMAScript/JavaScript代码的分析工具，根据编写的规则检测代码语法和风格错误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用；&lt;/li&gt;
&lt;li&gt;包含代码风格检测的规则；&lt;/li&gt;
&lt;li&gt;支持插件扩展、自定义规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;通过npm安到本地node_modules&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd到工程目录
npm i --save-dev eslint eslint-plugin-react eslint-plugin-react-native
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;cd到工程目录
创建或导入配置文件：eslint --init
开始分析代码：eslint test.js test2.js或eslint 目录/
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于项目进度与项目质量问题的解决方案</title>
    <link href="http://yoursite.com/2016/06/29/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2016/06/29/关于项目进度与项目质量问题的解决方案/</id>
    <published>2016-06-29T01:21:34.000Z</published>
    <updated>2018-03-01T05:49:39.754Z</updated>
    
    <content type="html"><![CDATA[<p>关于项目进度与项目质量问题的解决方案，由车大侠总结并同步发布到了简书：<a href="http://www.jianshu.com/p/399558f1f471" target="_blank" rel="noopener">http://www.jianshu.com/p/399558f1f471</a></p><p>主要从以下几个方面解决：</p><ul><li>明确开发流程，并明确每个阶段对应人员的工作职责</li><li>选择一款合适的团队协作工具对整个开发流程进度进行把控</li><li>人事部需要制定合适的绩效考核制度，提高员工工作积极性及责任感</li><li>对沟通方式、文档管理、代码规范、项目交付管理等方面进行规范</li><li>对可能造成项目延期的客观原因应该及时与客户沟通并保留记录</li><li>应当有专人担当项目经理一职，负责整个项目的开发进度及质量</li></ul><a id="more"></a><p>具体的解决方案如下：</p><h2 id="明确开发流程"><a href="#明确开发流程" class="headerlink" title="明确开发流程"></a>明确开发流程</h2><p>明确开发流程，并明确每个阶段对应人员的工作职责，需要指定明确的开发流程以及合理的任务分工。</p><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>参与人员：设计部相关成员<br>工作内容：完成项目前期设计、明确客户需求、完成需求确认书<br>产出物：原型图、业务流程图、需求确认书、开发过程中需要的素材（如用户协议、产品中需要用到的音乐图片等）</p><p><strong>注意事项：</strong></p><ul><li>原型图应该尽可能的做到每个界面都清晰易懂、对于有多种跳转结果的页面，应当注释标注</li><li>业务流程图应该对整个业务流程进行梳理，并产出文档，具体格式参考下图</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2105977-c5cf5512e6d8ff75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="业务流程图"></p><ul><li>需求确认书在签订时，应该告知客户修改需求会造成项目延期及成本增加的风险，规避客户在研发阶段做一些无意义的附加修改，影响研发组进度。</li><li>某些复杂功能的实现需要与研发组负责人协商、以评估项目进度及风险。</li><li>需求确认书必须覆盖所有已确认的需求，同时一旦定稿签订不得修改，后续的修改请客户直接与研发组负责人联系。</li></ul><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>参与人员：研发部参与项目的全体成员<br>工作内容：充分理解需求、定义编码规则（命名风格、通用约束等）、召开项目启动会议、项目经理制定开发计划、开发人员进行开发并保证代码质量<br>产出物：项目启动会议记录、编码规则文档、开发计划</p><p><strong>注意事项：</strong></p><ul><li>在项目开始前，开发人员应该仔细阅读需求文档及业务流程图，保证能够理解需求。</li><li>编码规则应该包含：①命名规则（类、对象、文件、组件、函数、方法等） ②编码风格（缩进、换行、块大小、文件大小、注释等）③框架搭建负责人、版本提交负责人、提交方式</li><li>启动会议所有项目组成员必须参加，对于项目存在的疑问要及时提出并讨论解决方案。</li><li>项目经理在启动会议结束后需要制定开发计划，分配开发任务、设置开发时间节点。</li><li>开发人员在完成模块功能编写后必须进行自测，如果一般性bug被测试组发现，可以采取减少绩效等处理措施。</li><li>将整个业务流程划分为多个user story，可以以每周任务的形式分配，测试人员根据story列出story测试用例，每周五下午进行所有开发人员进行本周story验收，如不通过，周末加班处理。</li><li>项目经理需要每日通过任务分配平台分配当日工作内容，以保证项目进度按时推进。</li><li>开发阶段，项目经理需要与客户直接接触，对于客户提出的需求变更，在评估变更风险后以邮件的形式告知客户处理意见，然后再做处理。同时，项目经理应该配合客户完成服务器购买、域名申请、开发者账号申请等工作。</li></ul><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>参与人员：测试组<br>工作内容：编写测试用例、执行测试用例、提交bug、跟踪bug直至关闭、提交测试报告<br>产出物：测试用例、bug列表、测试报告</p><p><strong>注意事项：</strong></p><ul><li>测试用例编写前要充分理解需求，要包含所有业务流程。</li><li>bug提交时应该描述清晰明了，需要截图的地方附上截图。</li><li>如果在验收阶段，客户反馈出现明显的严重bug，测试人员与对应的开发人员需承担相应责任。</li></ul><h2 id="选择合适的工具"><a href="#选择合适的工具" class="headerlink" title="选择合适的工具"></a>选择合适的工具</h2><p>选择一款合适的团队协作工具对整个开发流程进度进行把控。</p><p>推荐使用<a href="http://www.fishim.cn/" target="_blank" rel="noopener">鱼骨</a></p><h3 id="任务分配方式"><a href="#任务分配方式" class="headerlink" title="任务分配方式"></a>任务分配方式</h3><p><img src="http://upload-images.jianshu.io/upload_images/2105977-1af046032ac92aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务分配"></p><ul><li>可以对任务进行优先级、截止时间、对应项目、预计工时设置</li><li>每个任务有对应的负责人、抄送人、审核人</li><li>任务状态操作人性化</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2105977-cf285e1eb82966c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务操作"></p><h3 id="即时交流便捷"><a href="#即时交流便捷" class="headerlink" title="即时交流便捷"></a>即时交流便捷</h3><ul><li>可以直接针对单个任务发起相关人员的讨论</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2105977-6007657dd13bc6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![发起讨论](http://upload-images.jianshu.io/upload_images/2105977-75713cd2ec5ca140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"></p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li>可以将项目相关文件统一存放于鱼骨中</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2105977-fa32122d3bf221b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件管理"></p><p>总体来看，鱼骨的功能可以有效的解决公司现阶段面临的项目管理问题，但还需要从成本、私有化部署、易用性等方面考虑，需要开会商议。</p><h2 id="绩效考核制度"><a href="#绩效考核制度" class="headerlink" title="绩效考核制度"></a>绩效考核制度</h2><p>人事部需要制定合适的绩效考核制度，提高员工工作积极性及责任感。</p><ul><li>绩效考核制度的目的是提高员工工作积极性及责任感。</li><li>对于员工入职及离职流程应该建立完善的制度体系，入职需要进行入职培训、离职需要完成工作交接。</li></ul><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>对沟通方式、文档管理、代码规范、项目交付管理等方面进行规范。</p><ul><li>增强使用邮件的意识。</li><li>项目组每周至少要进行不少于两次的集体交流（交流不限制时间长短、方式、内容可以从需求到设计到实现、甚至是抱怨）。</li><li>项目文档应当有专人或项目经理管理并内部共享。</li><li>开发人员应该有良好的代码规范意识。</li><li>项目交付时，应当对安卓签名文件、ios开发者账号、数据库账号、服务器账号等一并提交给客户（如客户要求）或整理归档。</li></ul><h2 id="保持与客户的沟通"><a href="#保持与客户的沟通" class="headerlink" title="保持与客户的沟通"></a>保持与客户的沟通</h2><p>对可能造成项目延期的客观原因应该及时与客户沟通并保留记录。</p><ul><li>项目经理需要与客户直接接触，对于客户提出的需求变更，在评估变更风险后以邮件的形式告知客户处理意见，然后再做处理。</li></ul><h2 id="专人把控项目进度"><a href="#专人把控项目进度" class="headerlink" title="专人把控项目进度"></a>专人把控项目进度</h2><p>应当有专人担当项目经理一职，负责整个项目的开发进度及质量</p><ul><li>项目经理角色至关重要，担任者需要内部讨论决定。</li></ul><blockquote><p>Tip：引入 Story 演示有什么好处</p></blockquote><ul><li><p>Story 验收测试用例从用户价值的角度定义了 Story 的最低质量标准。Story 演示通过评估这些用例的执行通过情况决定相应 Story 是否允许转测从而保证了转测 Story 的最低质量要求，有效降低了由于转测 Story 质量低下而导致的多次修正代码多次再转测的返工可能性。返工作为软件开发过程中一种最为常见的浪费现象，它不仅阻碍了<strong>进度</strong>，也降低了<strong>质量</strong>。因此，从短期角度看，Story 演示的好处在于它能够有效减低返工的可能性，提高 Story 代码的质量。</p></li><li><p>Story 演示是由开发人员和测试人员共同参与的。Story 演示所呈现的软件功能作为开发人员的作品，对于往往有着弊帚自珍心理的开发人员来说，他总是不愿看到其作品在他人面前出现缺陷的。因此，Story 演示前，开发人员必须做好充分的单元测试才能避免在演示时当众“出丑”。于是，通过一次次的 Story 演示可以强化开发人员的质量意识。而开发人员的质量意识很大程度上决定了bug的数量。毕竟bug不是由测试人员“发现”出来的，而是开发人员“创造”了大部分bug。</p></li><li><p>另一方面，Story 演示过程中，开发人员往往能够自己发现一些在此之前不曾发现的问题，这些由其自身发现的问题往往能给其留下深刻的印象因而有利于其避免下次再犯同样或者类似的错误。这有利于开发人员自身的持续改进，提高其个人能力。因此，从长期角度看，Story 演示的好处在于它强化了开发人员的质量意识，并促进开发人员个人能力的持续改进。</p></li><li><p>能够从短期和长期的角度去理解实施 Story 演示的好处非常重要，因为这会影响到我们如何具体实施 Story 演示。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于项目进度与项目质量问题的解决方案，由车大侠总结并同步发布到了简书：&lt;a href=&quot;http://www.jianshu.com/p/399558f1f471&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jianshu.com/p/399558f1f471&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要从以下几个方面解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明确开发流程，并明确每个阶段对应人员的工作职责&lt;/li&gt;
&lt;li&gt;选择一款合适的团队协作工具对整个开发流程进度进行把控&lt;/li&gt;
&lt;li&gt;人事部需要制定合适的绩效考核制度，提高员工工作积极性及责任感&lt;/li&gt;
&lt;li&gt;对沟通方式、文档管理、代码规范、项目交付管理等方面进行规范&lt;/li&gt;
&lt;li&gt;对可能造成项目延期的客观原因应该及时与客户沟通并保留记录&lt;/li&gt;
&lt;li&gt;应当有专人担当项目经理一职，负责整个项目的开发进度及质量&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="质量管理" scheme="http://yoursite.com/categories/%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>App开发过程中常见问题分析</title>
    <link href="http://yoursite.com/2016/06/24/App%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/06/24/App开发过程中常见问题分析/</id>
    <published>2016-06-24T01:38:04.000Z</published>
    <updated>2018-03-01T05:49:39.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h2><h3 id="取值写死了"><a href="#取值写死了" class="headerlink" title="取值写死了"></a>取值写死了</h3><p>之前调试的时候，取了三条数据，所以取值的时候就按照index,0,1,2来取值，忽略了后台没有返回值的情况下去取值就会报数组越界。例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc]initWithObjects:@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *number = [array objectAtIndex:<span class="number">4</span>];</span><br></pre></td></tr></table></figure></p><h3 id="for循环取值越界"><a href="#for循环取值越界" class="headerlink" title="for循环取值越界"></a>for循环取值越界</h3><p>列表中时count+1行，然而取值时还是按照顺序来取值。<br><a id="more"></a><br>例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc]initWithObjects:@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSInteger</span> count = array.count;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [array objectAtIndex:i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for循环取值是下标是[0, count-1]的闭区间。</p><h3 id="数据返回为空"><a href="#数据返回为空" class="headerlink" title="数据返回为空"></a>数据返回为空</h3><p>数据返回为空是指后台返回的数据数组是空的，然而没有做空判断就去取值，导致数组越界的异常。</p><p>所以取值前需要先判断数组的长度然后再根据数组长度来取值。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (array &amp;&amp; array.count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [array objectAtIndex:<span class="number">5</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多层for循环取值混乱"><a href="#多层for循环取值混乱" class="headerlink" title="多层for循环取值混乱"></a>多层for循环取值混乱</h3><p>嵌套循环取值，取值错误把i取成了j，j取成了i，这是需要特别小心的地方。比如下面这个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *arrayA = [[<span class="built_in">NSMutableArray</span> alloc]initWithObjects:@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *arrayB = [[<span class="built_in">NSMutableArray</span> alloc]initWithObjects:@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSInteger</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= arrayA.count; i++) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [arrayA objectAtIndex:i]);</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; arrayB.count; j++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [arrayB objectAtIndex:i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面刷新问题"><a href="#页面刷新问题" class="headerlink" title="页面刷新问题"></a>页面刷新问题</h2><p>比较常见的页面刷新问题主要有，当你做了某些操作时，，其它页面的相关联的数据需要得到及时的刷新。</p><h2 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h2><h3 id="创建的实例没有释放"><a href="#创建的实例没有释放" class="headerlink" title="创建的实例没有释放"></a>创建的实例没有释放</h3><p>这里举个例子，体现得最明显的地方就是地图的释放，如果你在离开这个页面的时候不释放地图控件，当你来回切换地图界面和非地图界面时将会出现卡死的情况。</p><h3 id="block的使用"><a href="#block的使用" class="headerlink" title="block的使用"></a>block的使用</h3><p>oc情况下使用block使用self.xx导致循环引用无法释放。</p><h3 id="代理的使用"><a href="#代理的使用" class="headerlink" title="代理的使用"></a>代理的使用</h3><p>oc情况下声明代理的使用用了strong而不是assign。</p><h2 id="逻辑处理"><a href="#逻辑处理" class="headerlink" title="逻辑处理"></a>逻辑处理</h2><ol><li>情况考虑过少。</li><li>情况复杂就先放下，抱有侥幸心理。</li></ol><h2 id="后台的一些问题"><a href="#后台的一些问题" class="headerlink" title="后台的一些问题"></a>后台的一些问题</h2><p>很多时候App的一些错误都是由后台造成的，比较常见的问题有：</p><h3 id="返回字段不统一"><a href="#返回字段不统一" class="headerlink" title="返回字段不统一"></a>返回字段不统一</h3><p>比如说同样一个对象User，有时候返回userName,有时侯返回name。</p><h3 id="返回状态码不统一"><a href="#返回状态码不统一" class="headerlink" title="返回状态码不统一"></a>返回状态码不统一</h3><p>一会儿成功状态码是200，一会儿是300。</p><h3 id="字段名称更改"><a href="#字段名称更改" class="headerlink" title="字段名称更改"></a>字段名称更改</h3><p>之前调试都是好好的，突然一下没有获取到值了，原因很有可能就是后台接口返回的字段改变了。</p><blockquote><p>注意：后台字段一定要统一不要随意更改，若有更改需要通知App组相关开发人员。</p></blockquote><h3 id="字段删减"><a href="#字段删减" class="headerlink" title="字段删减"></a>字段删减</h3><p>这个问题和上面差不多，返回突然少了一个字段。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>后台设计接口的时候一定要考虑到分页，只要有列表的页面都应该考虑到分页的情况，不要到后面才想起要加分页，这个问题要从一开始设计接口的时候就要尽量避免。</p><h2 id="需求理解"><a href="#需求理解" class="headerlink" title="需求理解"></a>需求理解</h2><p>这个是最要命的问题，人家要做一辆火车，而你需求理解错误造出了一辆汽车。到了后期交付的时候，这可怎么交付啊！</p><h3 id="没有看原型图"><a href="#没有看原型图" class="headerlink" title="没有看原型图"></a>没有看原型图</h3><p>很多时候，原型图都还没有理解透彻就已经开始在编码了，这会出现什么情况呢？这有可能会直接导致你写的程序就是bug，没有一个功能是可以交付的。</p><h3 id="前后台理解不一致"><a href="#前后台理解不一致" class="headerlink" title="前后台理解不一致"></a>前后台理解不一致</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组越界&quot;&gt;&lt;a href=&quot;#数组越界&quot; class=&quot;headerlink&quot; title=&quot;数组越界&quot;&gt;&lt;/a&gt;数组越界&lt;/h2&gt;&lt;h3 id=&quot;取值写死了&quot;&gt;&lt;a href=&quot;#取值写死了&quot; class=&quot;headerlink&quot; title=&quot;取值写死了&quot;&gt;&lt;/a&gt;取值写死了&lt;/h3&gt;&lt;p&gt;之前调试的时候，取了三条数据，所以取值的时候就按照index,0,1,2来取值，忽略了后台没有返回值的情况下去取值就会报数组越界。例如：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *array = [[&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc]initWithObjects:@&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,@&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,@&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *number = [array objectAtIndex:&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;for循环取值越界&quot;&gt;&lt;a href=&quot;#for循环取值越界&quot; class=&quot;headerlink&quot; title=&quot;for循环取值越界&quot;&gt;&lt;/a&gt;for循环取值越界&lt;/h3&gt;&lt;p&gt;列表中时count+1行，然而取值时还是按照顺序来取值。&lt;br&gt;
    
    </summary>
    
    
      <category term="问题分析" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 学习笔记 2</title>
    <link href="http://yoursite.com/2016/06/20/RxAndroid-2/"/>
    <id>http://yoursite.com/2016/06/20/RxAndroid-2/</id>
    <published>2016-06-20T07:32:31.000Z</published>
    <updated>2018-03-01T05:49:39.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RxJava-的适用场景和使用方式"><a href="#RxJava-的适用场景和使用方式" class="headerlink" title="RxJava 的适用场景和使用方式"></a>RxJava 的适用场景和使用方式</h3><h4 id="1、与-Retrofit-的结合"><a href="#1、与-Retrofit-的结合" class="headerlink" title="1、与 Retrofit 的结合"></a>1、与 Retrofit 的结合</h4><p>Retrofit 是 Square 的一个著名的网络请求库。没有用过 Retrofit 的可以选择跳过这一小节也没关系，我举的每种场景都只是个例子，而且例子之间并无前后关联，只是个抛砖引玉的作用，所以你跳过这里看别的场景也可以的。<br><a id="more"></a><br>Retrofit 除了提供了传统的 <code>Callback</code> 形式的 API，还有 RxJava 版本的 <code>Observable</code> 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。</p><p>以获取一个 User 对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"web/app.php/funmi/user"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">(@Field(<span class="string">"userName"</span>)</span> String userName,</span></span><br><span class="line"><span class="function">              @<span class="title">Field</span><span class="params">(<span class="string">"password"</span>)</span> String password, @<span class="title">Field</span><span class="params">(<span class="string">"stype"</span>)</span> <span class="keyword">int</span> stype,</span></span><br><span class="line"><span class="function">              Callback&lt;User&gt; callback)</span>;</span><br></pre></td></tr></table></figure></p><p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getUser(userName,password,stype, <span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userView.setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error handling</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>而使用 RxJava 形式的 API，定义同样的请求是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line">   <span class="meta">@POST</span>(<span class="string">"web/app.php/funmi/user"</span>)</span><br><span class="line">   Observable&lt;BaseEntity&lt;User&gt;&gt; getUser(<span class="meta">@Field</span>(<span class="string">"userName"</span>) String userName,</span><br><span class="line">                                             <span class="meta">@Field</span>(<span class="string">"password"</span>) String password, <span class="meta">@Field</span>(<span class="string">"stype"</span>) <span class="keyword">int</span> stype);</span><br></pre></td></tr></table></figure></p><p>使用的时候是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getUser(userName,password,stype)</span><br><span class="line">   .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">   .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Error handling</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p><p>再举一个例子：假设 <code>/user</code> 接口并不能直接访问，而需要填入一个在线获取的 <code>token</code> ，代码应该怎么写？</p><p><code>Callback</code> 方式，可以使用嵌套的 <code>Callback</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"web/app.php/funmi/token"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getToken</span><span class="params">(Callback&lt;String&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"web/app.php/funmi/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(@Query(<span class="string">"token"</span>)</span> String token, @<span class="title">Query</span><span class="params">(<span class="string">"userId"</span>)</span> String userId, Callback&lt;User&gt; callback)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">getToken(<span class="keyword">new</span> Callback&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        getUser(token, userId, <span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">                userView.setUser(user);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Error handling</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error handling</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>而使用 RxJava 的话，代码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"web/app.php/funmi/token"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">getToken</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"web/app.php/funmi/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">getUser</span><span class="params">(@Query(<span class="string">"token"</span>)</span> String token, @<span class="title">Query</span><span class="params">(<span class="string">"userId"</span>)</span> String userId)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">getToken()</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">onNext</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getUser(token, userId);</span><br><span class="line">        &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Error handling</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p><p>用一个 <code>flatMap()</code> 就搞定了逻辑，依然是一条链。看着就很爽，是吧？</p><h4 id="2、-RxBinding"><a href="#2、-RxBinding" class="headerlink" title="2、 RxBinding"></a>2、 RxBinding</h4><p><a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">RxBinding</a> 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 <code>OnClickListener</code> 、设置 <code>TextWatcher</code> 这样的注册绑定对象的 API。</p><p>举个设置点击监听的例子。使用 <code>RxBinding</code> ，可以把事件监听用这样的方法来设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Button button = ...;</span><br><span class="line">RxView.clickEvents(button) <span class="comment">// 以 Observable 形式来反馈点击事件</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;ViewClickEvent&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(ViewClickEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Click handling</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p><p>看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 <code>setOnClickListener()</code> 来实现的。然而，仅仅这一个形式的改变，却恰好就是 <code>RxBinding</code> 的目的：扩展性。通过 <code>RxBinding</code> 把点击监听转换成 <code>Observable</code> 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 <code>throttleFirst()</code> ，用于去抖动，也就是消除手抖导致的快速连环点击：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RxView.clickEvents(button)</span><br><span class="line">   .throttleFirst(<span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">   .subscribe(clickAction);</span><br></pre></td></tr></table></figure></p><h4 id="3、各种异步操作"><a href="#3、各种异步操作" class="headerlink" title="3、各种异步操作"></a>3、各种异步操作</h4><p>前面举的 <code>Retrofit</code> 和 <code>RxBinding</code> 的例子，是两个可以提供现成的 <code>Observable</code> 的库。而如果你有某些异步操作无法用这些库来自动生成 <code>Observable</code>，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 <code>RxJava</code> 来实现，有了之前几章的例子，这里应该不用再举例了。</p><h4 id="4、RxBus"><a href="#4、RxBus" class="headerlink" title="4、RxBus"></a>4、RxBus</h4><p><code>RxBus</code> 名字看起来像一个库，但它并不是一个库，而是一种模式，它的思想是使用 <code>RxJava</code> 来实现了 <code>EventBus</code> ，而让你不再需要使用 <code>Otto</code> 或者 GreenRobot 的 <code>EventBus</code>。至于什么是 RxBus，可以看这篇文章。顺便说一句，Flipboard 已经用 <code>RxBus</code> 替换掉了 <code>Otto</code> ，目前为止没有不良反应。</p><h4 id="部分内容摘自-扔物线"><a href="#部分内容摘自-扔物线" class="headerlink" title="部分内容摘自 扔物线"></a>部分内容摘自 <a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">扔物线</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RxJava-的适用场景和使用方式&quot;&gt;&lt;a href=&quot;#RxJava-的适用场景和使用方式&quot; class=&quot;headerlink&quot; title=&quot;RxJava 的适用场景和使用方式&quot;&gt;&lt;/a&gt;RxJava 的适用场景和使用方式&lt;/h3&gt;&lt;h4 id=&quot;1、与-Retrofit-的结合&quot;&gt;&lt;a href=&quot;#1、与-Retrofit-的结合&quot; class=&quot;headerlink&quot; title=&quot;1、与 Retrofit 的结合&quot;&gt;&lt;/a&gt;1、与 Retrofit 的结合&lt;/h4&gt;&lt;p&gt;Retrofit 是 Square 的一个著名的网络请求库。没有用过 Retrofit 的可以选择跳过这一小节也没关系，我举的每种场景都只是个例子，而且例子之间并无前后关联，只是个抛砖引玉的作用，所以你跳过这里看别的场景也可以的。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 学习笔记 1</title>
    <link href="http://yoursite.com/2016/06/07/RxAndroid-1/"/>
    <id>http://yoursite.com/2016/06/07/RxAndroid-1/</id>
    <published>2016-06-07T07:40:53.000Z</published>
    <updated>2018-03-01T05:49:39.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RxJava-是什么？"><a href="#RxJava-是什么？" class="headerlink" title="RxJava 是什么？"></a>RxJava 是什么？</h3><p>我的理解就是观察者模式，RxJava 最核心的东西就是 <strong>Observable</strong> （<code>被观察者</code>） 和 <strong>Observer</strong> (<code>观察者</code>) 。</p><p><strong>Observable</strong> （<code>被观察者</code>） 会发出数据，而与之相对的 <strong>Observer</strong> (<code>观察者</code>) 则会通过订阅<strong>Observable</strong>（<code>被观察者</code>） 来进行观察。</p><p><strong>Observer</strong>可以在<strong>Observable</strong>发出数据、报错或者声明没有数据可以发送时进行相应的操作。这三个操作被封装在<strong>Observer</strong>接口中，相应的方法为<code>onNext()</code>，<code>onError()</code>和<code>onCompleted()</code>。</p><h3 id="RxJava的优点"><a href="#RxJava的优点" class="headerlink" title="RxJava的优点"></a>RxJava的优点</h3><p>所有的逻辑业务都封装成一条链式结构，使其看起来很 <strong>简洁</strong>。<br><a id="more"></a></p><p>  <img src="http://ww4.sinaimg.cn/large/52eb2279jw1f2rx409pcnj2044048mx5.jpg" alt=""></p><h4 id="加载Assets文件夹下的图片"><a href="#加载Assets文件夹下的图片" class="headerlink" title="加载Assets文件夹下的图片"></a>加载Assets文件夹下的图片</h4><pre><code>private String[] imgPath = null;private void loadImage() {    try {        //这里注意  只能返回  Assets 下某一个文件夹下的所有文件，不能返回 Assets下所有文件        imgPath = getAssets().list(&quot;ssdk&quot;);    } catch (IOException e) {        e.printStackTrace();    }    if (null == imgPath &amp;&amp; imgPath.length == 0) {        Log.e(tag, &quot;图片地址  为空&quot;);        return;    }    new Thread(new Runnable() {        @Override        public void run() {            for (int i = 0; i &lt; imgPath.length; i++) {                //一个坑，要把文件夹的路径也加上                InputStream is = null;                Bitmap bitmap = null;                try {                    is = getAssets().open(&quot;ssdk/&quot; + imgPath[i]);                    bitmap = BitmapFactory.decodeStream(is);                } catch (IOException e) {                    e.printStackTrace();                }                final ImageView imageView = new ImageView(mContext);                // 设置当前图像的图像（position为当前图像列表的位置）                imageView.setLayoutParams(new LinearLayout.LayoutParams(                        200, 200));                // 设置Gallery组件的背景风格                imageView.setImageBitmap(bitmap);                runOnUiThread(new Runnable() {                    @Override                    public void run() {                        rootView.addView(imageView);                    }                });            }        }    }).start();}</code></pre><h4 id="加载Assets文件夹下的图片-使用-RxJava"><a href="#加载Assets文件夹下的图片-使用-RxJava" class="headerlink" title="加载Assets文件夹下的图片 使用 RxJava"></a>加载Assets文件夹下的图片 使用 RxJava</h4><pre><code>private void loadImage() {    String[] imgUrl = null;    try {        //这里注意  只能返回  Assets 下某一个文件夹下的所有文件，不能返回 Assets下所有文件        imgUrl = getAssets().list(&quot;ssdk&quot;);    } catch (IOException e) {        e.printStackTrace();    }    if (null == imgUrl &amp;&amp; imgUrl.length == 0) {        Log.e(tag, &quot;图片地址  为空&quot;);        return;    }    Observable.from(imgUrl)            .map(new Func1&lt;String, Bitmap&gt;() {                @Override                public Bitmap call(String s) {                    Bitmap bitmap = null;                    try {                        //一个坑，要把文件夹的路径也加上                        InputStream is = getAssets().open(&quot;ssdk/&quot; + s);                        bitmap = BitmapFactory.decodeStream(is);                    } catch (IOException e) {                        e.printStackTrace();                    }                    if (null == bitmap) {                        return null;                    } else {                        return bitmap;                    }                }            })            .subscribeOn(Schedulers.io())            .observeOn(AndroidSchedulers.mainThread())            .subscribe(new Observer&lt;Bitmap&gt;() {                @Override                public void onCompleted() {                }                @Override                public void onError(Throwable e) {                }                @Override                public void onNext(Bitmap bitmap) {                    if (null == bitmap) {                        Log.e(tag, &quot;bitmap为空&quot;);                        return;                    }                    ImageView imageView = new ImageView(mContext);                    // 设置当前图像的图像（position为当前图像列表的位置）                    imageView.setLayoutParams(new LinearLayout.LayoutParams(                            200, 200));                    // 设置Gallery组件的背景风格                    imageView.setImageBitmap(bitmap);                    rootView.addView(imageView);                }            });}</code></pre><p>看起来使用RxJava 代码量还变多了，但是逻辑更加简洁了，从上到下，一步一步，逻辑非常明确，没有嵌套，一眼明了。</p><h4 id="RxJava-基本实现"><a href="#RxJava-基本实现" class="headerlink" title="RxJava 基本实现"></a>RxJava 基本实现</h4><h5 id="创建-Observer-观察者"><a href="#创建-Observer-观察者" class="headerlink" title="创建 Observer (观察者)"></a>创建 Observer (观察者)</h5><p><code>Observer</code> 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 <code>Observer</code> 接口的实现方式：</p><pre><code>Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {    @Override    public void onNext(String s) {        Log.d(tag, &quot;Item: &quot; + s);    }    @Override    public void onCompleted() {        Log.d(tag, &quot;Completed!&quot;);    }    @Override    public void onError(Throwable e) {        Log.d(tag, &quot;Error!&quot;);    }};</code></pre><p>除了 <code>Observer</code> 接口之外，RxJava 还内置了一个实现了<code>Observer</code> 的抽象类：<code>Subscriber</code>。 <code>Subscriber</code> 对 <code>Observer</code> 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p><pre><code>Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {    @Override    public void onNext(String s) {        Log.d(tag, &quot;Item: &quot; + s);    }    @Override    public void onCompleted() {        Log.d(tag, &quot;Completed!&quot;);    }    @Override    public void onError(Throwable e) {        Log.d(tag, &quot;Error!&quot;);    }};</code></pre><p>不仅基本使用方式一样，实质上，在 RxJava 的 <code>subscribe</code> 过程中，<code>Observer</code> 也总是会先被转换成一个 <code>Subscriber</code> 再使用。所以如果你只想使用基本功能，选择 <code>Observer</code> 和 <code>Subscriber</code> 是完全一样的。它们的区别对于使用者来说主要有两点：</p><ol><li><code>onStart()</code>: 这是 <code>Subscriber</code> 增加的方法。它会在 <code>subscribe</code> 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， <code>onStart()</code> 就不适用了，因为它总是在 <code>subscribe</code> 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 <code>doOnSubscribe()</code> 方法，具体可以在后面的文中看到。</li><li><code>unsubscribe()</code>: 这是 <code>Subscriber</code> 所实现的另一个接口 <code>Subscription</code> 的方法，用于取消订阅。在这个方法被调用后，<code>Subscriber</code> 将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 <code>unsubscribe()</code> 这个方法很重要，因为在 <code>subscribe()</code> 之后， <code>Observable</code> 会持有 <code>Subscriber</code> 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 <code>onPause()</code> <code>onStop()</code> 等方法中）调用 <code>unsubscribe()</code> 来解除引用关系，以避免内存泄露的发生。</li></ol><h5 id="创建-Observable-被观察者"><a href="#创建-Observable-被观察者" class="headerlink" title="创建 Observable (被观察者)"></a>创建 Observable (被观察者)</h5><p><code>Observable</code> 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 <code>create()</code> 方法来创建一个 <code>Observable</code> ，并为它定义事件触发规则：</p><pre><code>Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {    @Override    public void call(Subscriber&lt;? super String&gt; subscriber) {        subscriber.onNext(&quot;Hello&quot;);        subscriber.onNext(&quot;Hi&quot;);        subscriber.onNext(&quot;Aloha&quot;);        subscriber.onCompleted();    }});</code></pre><p>可以看到，这里传入了一个 <code>OnSubscribe</code> 对象作为参数。<code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中，它的作用相当于一个计划表，当 <code>Observable</code> 被订阅的时候，<code>OnSubscribe</code> 的 <code>call()</code> 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者<code>Subscriber</code> 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p><p><code>create()</code> 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如：</p><ul><li><p><code>just(T...)</code>: 将传入的参数依次发送出来。</p><pre><code>Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);// 将会依次调用：// onNext(&quot;Hello&quot;);// onNext(&quot;Hi&quot;);// onNext(&quot;Aloha&quot;);// onCompleted();</code></pre></li><li><p><code>from(T[])</code> / <code>from(Iterable&lt;? extends T&gt;)</code> : 将传入的数组或 <code>Iterable</code> 拆分成具体对象后，依次发送出来。</p><pre><code>String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};Observable observable = Observable.from(words);// 将会依次调用：// onNext(&quot;Hello&quot;);// onNext(&quot;Hi&quot;);// onNext(&quot;Aloha&quot;);// onCompleted();</code></pre></li></ul><p>上面 <code>just(T...)</code> 的例子和 <code>from(T[])</code> 的例子，都和之前的 <code>create(OnSubscribe)</code> 的例子是等价的。</p><h4 id="Subscribe-订阅"><a href="#Subscribe-订阅" class="headerlink" title="Subscribe (订阅)"></a>Subscribe (订阅)</h4><p>创建了 <code>Observable</code> 和 <code>Observer</code> 之后，再用 <code>subscribe()</code> 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p><pre><code>observable.subscribe(observer);// 或者：observable.subscribe(subscriber);</code></pre><blockquote><p>有人可能会注意到， <code>subscribe()</code> 这个方法有点怪：它看起来是『<code>observalbe</code> 订阅了<code>observer</code> / <code>subscriber</code>』而不是『<code>observer</code> / <code>subscriber</code> 订阅了 <code>observalbe</code>』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 <code>observer.subscribe(observable)</code> / <code>subscriber.subscribe(observable)</code> ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>a. 打印字符串数组</p><pre><code>String[] names = ...;Observable.from(names).subscribe(new Action1&lt;String&gt;() {@Overridepublic void call(String name) {    Log.d(tag, name);}   });</code></pre><p>b. 由 id 取得图片并显示</p><pre><code>int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() {    @Override    public void call(Subscriber&lt;? super Drawable&gt; subscriber) {        Drawable drawable = getTheme().getDrawable(drawableRes));        subscriber.onNext(drawable);        subscriber.onCompleted();    }    }).subscribe(new Observer&lt;Drawable&gt;() {    @Override    public void onNext(Drawable drawable) {        imageView.setImageDrawable(drawable);    }    @Override    public void onCompleted() {    }    @Override    public void onError(Throwable e) {        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();    }});</code></pre><p>正如上面两个例子这样，创建出 <code>Observable</code> 和 <code>Subscriber</code> ，再用 <code>subscribe()</code> 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。<br>然而，</p><p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ddcncj2046053gll.jpg" alt=""></p><p>在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念：<code>Scheduler</code> 。</p><h4 id="线程控制-——-Scheduler"><a href="#线程控制-——-Scheduler" class="headerlink" title="线程控制 —— Scheduler"></a>线程控制 —— Scheduler</h4><h5 id="Scheduler-的-API"><a href="#Scheduler-的-API" class="headerlink" title="Scheduler 的 API"></a>Scheduler 的 API</h5><p>在RxJava 中，<code>Scheduler</code> ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 <code>Scheduler</code> ，它们已经适合大多数的使用场景：</p><ul><li><code>Schedulers.immediate()</code>: 直接在当前线程运行，相当于不指定线程。这是默认的 <code>Scheduler</code>。</li><li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li><li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 <code>newThread()</code> 差不多，区别在于 <code>io()</code> 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 <code>io()</code> 比 <code>newThread()</code> 更有效率。不要把计算工作放在 <code>io()</code> 中，可以避免创建不必要的线程。</li><li><code>Schedulers.computation()</code>: 计算所使用的 <code>Scheduler</code>。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 <code>Scheduler</code> 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 <code>computation()</code> 中，否则 I/O 操作的等待时间会浪费 CPU。</li><li>另外， Android 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 Android 主线程运行。</li></ul><p>有了这几个 <code>Scheduler</code> ，就可以使用 <code>subscribeOn()</code> 和 <code>observeOn()</code> 两个方法来对线程进行控制了。 <code>subscribeOn()</code>: 指定 <code>subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。或者叫做事件产生的线程。 <code>observeOn()</code>: 指定 <code>Subscriber</code> 所运行在的线程。或者叫做事件消费的线程。</p><p>文字叙述总归难理解，上代码：</p><pre><code>Observable.just(1, 2, 3, 4)    .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程    .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程    .subscribe(new Action1&lt;Integer&gt;() {        @Override        public void call(Integer number) {            Log.d(tag, &quot;number:&quot; + number);        }    });</code></pre><p>上面这段代码中，由于 <code>subscribeOn(Schedulers.io())</code> 的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于 <code>observeOn(AndroidScheculers.mainThread())</code> 的指定，因此 <code>subscriber</code> 数字的打印将发生在主线程 。事实上，这种在 <code>subscribe()</code> 之前写上两句 <code>subscribeOn(Scheduler.io())</code> 和 <code>observeOn(AndroidSchedulers.mainThread())</code> 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。</p><p>而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p><pre><code>    int drawableRes = ...;    ImageView imageView = ...;    Observable.create(new OnSubscribe&lt;Drawable&gt;() {        @Override        public void call(Subscriber&lt;? super Drawable&gt; subscriber) {            Drawable drawable = getTheme().getDrawable(drawableRes));            subscriber.onNext(drawable);            subscriber.onCompleted();        }    })    .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程    .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程    .subscribe(new Observer&lt;Drawable&gt;() {        @Override        public void onNext(Drawable drawable) {            imageView.setImageDrawable(drawable);        }        @Override        public void onCompleted() {        }        @Override        public void onError(Throwable e) {            Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();        }});</code></pre><p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p><h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><p>终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。</p><p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。</p><h5 id="1-map"><a href="#1-map" class="headerlink" title="(1) map()"></a>(1) <code>map()</code></h5><p>首先看一个 <code>map()</code> 的例子：</p><pre><code>Observable.just(&quot;images/logo.png&quot;) // 输入类型 String.map(new Func1&lt;String, Bitmap&gt;() {    @Override    public Bitmap call(String filePath) { // 参数类型 String        return getBitmapFromPath(filePath); // 返回类型 Bitmap    }}).subscribe(new Action1&lt;Bitmap&gt;() {    @Override    public void call(Bitmap bitmap) { // 参数类型 Bitmap        showBitmap(bitmap);    }});</code></pre><p>这里出现了一个叫做 <code>Func1</code> 的类。它和 <code>Action1</code> 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 <code>Func1</code> 和 <code>Action</code> 的区别在于， <code>Func1</code> 包装的是有返回值的方法。另外，和 <code>ActionX</code> 一样， <code>FuncX</code> 也有多个，用于不同参数个数的方法。<code>FuncX</code> 和 <code>ActionX</code> 的区别在 <code>FuncX</code> 包装的是有返回值的方法。</p><p>可以看到，<code>map()</code> 方法将参数中的 <code>String</code> 对象转换成一个 <code>Bitmap</code> 对象后返回，而在经过 <code>map()</code> 方法后，事件的参数类型也由 <code>String</code> 转为了 <code>Bitmap</code>。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：</p><ul><li><p><code>map()</code>: 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 <code>map()</code> 的示意图：<br><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg" alt=""></p></li><li><p><code>flatMap()</code>:这是一个很有用但 <strong>非常难理解</strong> 的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</p><pre><code>Student[] students = ...;Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {    @Override    public void onNext(String name) {        Log.d(tag, name);    }    ...};Observable.from(students).map(new Func1&lt;Student, String&gt;() {    @Override    public String call(Student student) {        return student.getName();    }}).subscribe(subscriber);</code></pre></li></ul><p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p><pre><code>Student[] students = ...;Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() {    @Override    public void onNext(Student student) {        List&lt;Course&gt; courses = student.getCourses();        for (int i = 0; i &lt; courses.size(); i++) {            Course course = courses.get(i);            Log.d(tag, course.getName());        }    }    ...};Observable.from(students).subscribe(subscriber);</code></pre><p>依然很简单。那么如果我不想在 <code>Subscriber</code> 中使用 for 循环，而是希望 <code>Subscriber</code> 中直接传入单个的 <code>Course</code> 对象呢（这对于代码复用很重要）？用 <code>map()</code> 显然是不行的，因为 <code>map()</code> 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 <code>Student</code> 转化成多个 <code>Course</code> 呢？</p><p>这个时候，就需要用 <code>flatMap()</code> 了：</p><pre><code>Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() {    @Override    public void onNext(Course course) {        Log.d(tag, course.getName());    }    ...};Observable.from(students).flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() {    @Override    public Observable&lt;Course&gt; call(Student student) {        return Observable.from(student.getCourses());    }}).subscribe(subscriber);</code></pre><p>从上面的代码可以看出， <code>flatMap()</code> 和 <code>map()</code> 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 <code>map()</code> 不同的是， <code>flatMap()</code> 中返回的是个 <code>Observable</code> 对象，并且这个 <code>Observable</code> 对象并不是被直接发送到了 <code>Subscriber</code> 的回调方法中。 <code>flatMap(</code> 的原理是这样的：</p><ol><li>使用传入的事件对象创建一个 <code>Observable</code> 对象；</li><li>并不发送这个 <code>Observable</code>, 而是将它激活，于是它开始发送事件；</li><li>每一个创建出来的 <code>Observable</code> 发送的事件，都被汇入同一个 <code>Observable</code> ，而这个 <code>Observable</code> 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 <code>Observable</code> 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 <code>flatMap</code>() 所谓的 <code>flat</code>。</li></ol><p><code>flatMap()</code> 示意图：</p><p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg" alt=""></p><h5 id="线程控制：Scheduler"><a href="#线程控制：Scheduler" class="headerlink" title="线程控制：Scheduler"></a>线程控制：Scheduler</h5><p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p><p>因为 <code>observeOn()</code> 指定的是 <code>Subscriber</code> 的线程，而这个 <code>Subscriber</code> 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）<code>subscribe()</code> 参数中的 <code>Subscriber</code> ，而是 <code>observeOn()</code> 执行时的当前 <code>Observable</code> 所对应的 <code>Subscriber</code> ，即它的直接下级 <code>Subscriber</code> 。换句话说，<code>observeOn()</code> 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 <code>observeOn()</code> 即可。上代码：</p><pre><code>Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定    .subscribeOn(Schedulers.io())    .observeOn(Schedulers.newThread())    .map(mapOperator) // 新线程，由 observeOn() 指定    .observeOn(Schedulers.io())    .map(mapOperator2) // IO 线程，由 observeOn() 指定    .observeOn(AndroidSchedulers.mainThread)     .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定</code></pre><p>如上，通过<code>observeOn()</code> 的多次调用，程序实现了线程的多次切换。</p><p>不过，不同于 <code>observeOn()</code> ， <code>subscribeOn()</code> 的位置放在哪里都可以，但它是只能调用一次的。</p><h5 id="延伸：doOnSubscribe"><a href="#延伸：doOnSubscribe" class="headerlink" title="延伸：doOnSubscribe()"></a>延伸：doOnSubscribe()</h5><p>然而，虽然超过一个的 <code>subscribeOn()</code> 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p><p>在前面讲 <code>Subscriber</code> 的时候，提到过 <code>Subscriber</code> 的 <code>onStart()</code> 可以用作流程开始前的初始化。然而 <code>onStart()</code> 由于在 <code>subscribe()</code> 发生时就被调用了，因此不能指定线程，而是只能执行在 <code>subscribe()</code> 被调用时的线程。这就导致如果 <code>onStart()</code> 中含有对线程有要求的代码（例如在界面上显示一个 <code>ProgressBar</code>，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 <code>subscribe()</code> 将会在什么线程执行。</p><p>而与 <code>Subscriber.onStart()</code> 相对应的，有一个方法 <code>Observable.doOnSubscribe()</code> 。它和 <code>Subscriber.onStart()</code> 同样是在 <code>subscribe()</code> 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， <code>doOnSubscribe()</code> 执行在 <code>subscribe()</code>发生的线程；而如果在 <code>doOnSubscribe()</code> 之后有 <code>subscribeOn()</code> 的话，它将执行在离它最近的 <code>subscribeOn()</code> 所指定的线程。</p><p>示例代码：</p><pre><code>Observable.create(onSubscribe)    .subscribeOn(Schedulers.io())    .doOnSubscribe(new Action0() {        @Override        public void call() {            progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行        }    })    .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程    .observeOn(AndroidSchedulers.mainThread())    .subscribe(subscriber);</code></pre><p>如上，在<code>doOnSubscribe()</code>的后面跟一个 <code>subscribeOn()</code> ，就能指定准备工作的线程了。</p><h4 id="部分内容摘自-扔物线"><a href="#部分内容摘自-扔物线" class="headerlink" title="部分内容摘自 扔物线"></a>部分内容摘自 <a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">扔物线</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RxJava-是什么？&quot;&gt;&lt;a href=&quot;#RxJava-是什么？&quot; class=&quot;headerlink&quot; title=&quot;RxJava 是什么？&quot;&gt;&lt;/a&gt;RxJava 是什么？&lt;/h3&gt;&lt;p&gt;我的理解就是观察者模式，RxJava 最核心的东西就是 &lt;strong&gt;Observable&lt;/strong&gt; （&lt;code&gt;被观察者&lt;/code&gt;） 和 &lt;strong&gt;Observer&lt;/strong&gt; (&lt;code&gt;观察者&lt;/code&gt;) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Observable&lt;/strong&gt; （&lt;code&gt;被观察者&lt;/code&gt;） 会发出数据，而与之相对的 &lt;strong&gt;Observer&lt;/strong&gt; (&lt;code&gt;观察者&lt;/code&gt;) 则会通过订阅&lt;strong&gt;Observable&lt;/strong&gt;（&lt;code&gt;被观察者&lt;/code&gt;） 来进行观察。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Observer&lt;/strong&gt;可以在&lt;strong&gt;Observable&lt;/strong&gt;发出数据、报错或者声明没有数据可以发送时进行相应的操作。这三个操作被封装在&lt;strong&gt;Observer&lt;/strong&gt;接口中，相应的方法为&lt;code&gt;onNext()&lt;/code&gt;，&lt;code&gt;onError()&lt;/code&gt;和&lt;code&gt;onCompleted()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;RxJava的优点&quot;&gt;&lt;a href=&quot;#RxJava的优点&quot; class=&quot;headerlink&quot; title=&quot;RxJava的优点&quot;&gt;&lt;/a&gt;RxJava的优点&lt;/h3&gt;&lt;p&gt;所有的逻辑业务都封装成一条链式结构，使其看起来很 &lt;strong&gt;简洁&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods安装和使用教程</title>
    <link href="http://yoursite.com/2016/02/20/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/02/20/CocoaPods安装和使用教程/</id>
    <published>2016-02-20T01:14:02.000Z</published>
    <updated>2018-03-01T05:49:39.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CocosPods是什么"><a href="#CocosPods是什么" class="headerlink" title="CocosPods是什么"></a>CocosPods是什么</h2><p>CocoaPods是iOS项目的依赖管理工具，该项目源码在Github上管理。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和第三方开源库的时间。<br>在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要<br>1.把开源库的源代码复制到项目中<br>2.添加一些依赖框架和动态库<br>3.设置-ObjC，-fno-objc-arc等参数<br>4.管理他们的更新<br>在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install.Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。</p><a id="more"></a><h2 id="CocoaPods的原理"><a href="#CocoaPods的原理" class="headerlink" title="CocoaPods的原理"></a>CocoaPods的原理</h2><p>CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。</p><h2 id="CocoaPods的安装"><a href="#CocoaPods的安装" class="headerlink" title="CocoaPods的安装"></a>CocoaPods的安装</h2><p>CocoaPods可以方便地通过Mac自带的RubyGems安装。<br>打开Terminal，然后键入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p><p>执行完这句如果报告以下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a valid gem <span class="string">'cocoapods'</span> (&gt;= 0), here is why:</span><br><span class="line">Unable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Operation timed out - connect(2) (https://rubygems.org/latest_specs.4.8.gz)</span><br><span class="line">ERROR: Possible alternatives: cocoapods</span><br></pre></td></tr></table></figure></p><p>这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l (查看当前ruby的源)</span><br><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">$ gem sources -a https://gems.ruby-china.org/ <span class="comment">#https://ruby.taobao.org/</span></span><br><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure></p><p>如果gem太老，可以尝试用如下命令升级gem<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem update --system</span><br></pre></td></tr></table></figure></p><p>升级成功后会提示: RubyGems system software updated</p><p>然后重新执行安装下载命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p><p>这时候应该没什么问题了</p><p>接下来进行安装，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod setup</span><br></pre></td></tr></table></figure></p><p>Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.（文章末尾附使用镜像索引的方法）</p><h2 id="Cocoapods的使用"><a href="#Cocoapods的使用" class="headerlink" title="Cocoapods的使用"></a>Cocoapods的使用</h2><p>进入工程所在的目录（工程根目录）<br>执行命令 touch Podfile<br>这句是说新建一个名为Podfile的文件（不能写成别的名字，也可以自己在工程根目录里面直接新建）</p><p>然后对改文件进行编辑，执行命令 open -e Podfile<br>第一次执行这个命令,会有一个空白文件打开，可以先放在一边，<br>Podfile文件的格式应该如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'AMap2DMap'</span>, <span class="string">'~&gt; 2.5.0'</span></span><br><span class="line">pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.5.3'</span></span><br><span class="line">pod <span class="string">'SDWebImage'</span>, <span class="string">'~&gt; 3.7.2'</span></span><br></pre></td></tr></table></figure></p><p>需要注意的几点：platform那一行，ios三个字母都要小写，而且与前面的冒号之间不能有间隔，后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在6.0以上才能运行，遇到这样的开源库就需要写上版本号。</p><p>platform下面就是Cocoapods需要集成的开源库，根据你的需要确定集成那些库。</p><p>举个例子：<br>我要集成AFNetworking这个库类，需要在Cocoapods里面先搜索是否有需要的库，可以在Terminal中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod search AFNetworking</span><br></pre></td></tr></table></figure></p><p>回车之后就可以看到和你搜索的关键字相关的一些库类。</p><p>其中第一个就是我们需要的，把pod ‘AFNetworking’， ‘~&gt;2.5.3’<br>那一行复制到我们的Podfile文件中，保存修改。<br>然后在Terminal中执行 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure></p><p>这样，AFNetworking就已经下载完成并且设置好了编译参数和依赖，以后使用的时候切记如下两点：<br>1.从此以后需要使用Cocoapods生成的 .xcworkspace文件来打开工程，而不是使用以前的.xcodeproj文件<br>2.每次更改了Podfile文件，都需要重新执行一次pod update命令</p><p>ps:当执行pod install之后，除了Podfile，还会生成一个名为Podfile.lock的文件，它会锁定当前各依赖库的版本，之后即使多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock.在多人协作的时候，这样可以防止第三方库升级时候造成大家各自的第三方库版本不一致。所以在提交版本的时候不能把它落下，也不要添加到.gitignore中.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CocosPods是什么&quot;&gt;&lt;a href=&quot;#CocosPods是什么&quot; class=&quot;headerlink&quot; title=&quot;CocosPods是什么&quot;&gt;&lt;/a&gt;CocosPods是什么&lt;/h2&gt;&lt;p&gt;CocoaPods是iOS项目的依赖管理工具，该项目源码在Github上管理。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和第三方开源库的时间。&lt;br&gt;在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要&lt;br&gt;1.把开源库的源代码复制到项目中&lt;br&gt;2.添加一些依赖框架和动态库&lt;br&gt;3.设置-ObjC，-fno-objc-arc等参数&lt;br&gt;4.管理他们的更新&lt;br&gt;在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install.Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="cocoaPods" scheme="http://yoursite.com/tags/cocoaPods/"/>
    
  </entry>
  
</feed>
